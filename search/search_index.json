{"config":{"indexing":"full","lang":["en","pt"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;"},"docs":[{"location":"","text":"Sensor Network This repository holds the Sensor Network code stack for a LoRa based wireless sensor network.. teste Introduction Platforms","title":"Introduction"},{"location":"#sensor-network","text":"This repository holds the Sensor Network code stack for a LoRa based wireless sensor network.. teste","title":"Sensor Network"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#platforms","text":"","title":"Platforms"},{"location":"Gateway/Classes/","text":"Classes struct strMsg struct strPayload Updated on 2022-08-25 at 10:49:38 +0000","title":"Classes"},{"location":"Gateway/Classes/#classes","text":"struct strMsg struct strPayload Updated on 2022-08-25 at 10:49:38 +0000","title":"Classes"},{"location":"Gateway/Classes/structstr_msg/","text":"strMsg #include <comms_protocol.h> Public Attributes Name byte msg byte msgID char flag Public Attributes Documentation variable msg byte msg; variable msgID byte msgID; variable flag char flag; Updated on 2022-08-25 at 10:49:38 +0000","title":"strMsg"},{"location":"Gateway/Classes/structstr_msg/#strmsg","text":"#include <comms_protocol.h>","title":"strMsg"},{"location":"Gateway/Classes/structstr_msg/#public-attributes","text":"Name byte msg byte msgID char flag","title":"Public Attributes"},{"location":"Gateway/Classes/structstr_msg/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Gateway/Classes/structstr_msg/#variable-msg","text":"byte msg;","title":"variable msg"},{"location":"Gateway/Classes/structstr_msg/#variable-msgid","text":"byte msgID;","title":"variable msgID"},{"location":"Gateway/Classes/structstr_msg/#variable-flag","text":"char flag; Updated on 2022-08-25 at 10:49:38 +0000","title":"variable flag"},{"location":"Gateway/Classes/structstr_payload/","text":"strPayload #include <comms_protocol.h> Public Attributes Name byte nodeID byte sensorID byte msgID char flag byte sensorVal int RSSI float SNR Public Attributes Documentation variable nodeID byte nodeID; variable sensorID byte sensorID; variable msgID byte msgID; variable flag char flag; variable sensorVal byte sensorVal; variable RSSI int RSSI; variable SNR float SNR; Updated on 2022-08-25 at 10:49:38 +0000","title":"strPayload"},{"location":"Gateway/Classes/structstr_payload/#strpayload","text":"#include <comms_protocol.h>","title":"strPayload"},{"location":"Gateway/Classes/structstr_payload/#public-attributes","text":"Name byte nodeID byte sensorID byte msgID char flag byte sensorVal int RSSI float SNR","title":"Public Attributes"},{"location":"Gateway/Classes/structstr_payload/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Gateway/Classes/structstr_payload/#variable-nodeid","text":"byte nodeID;","title":"variable nodeID"},{"location":"Gateway/Classes/structstr_payload/#variable-sensorid","text":"byte sensorID;","title":"variable sensorID"},{"location":"Gateway/Classes/structstr_payload/#variable-msgid","text":"byte msgID;","title":"variable msgID"},{"location":"Gateway/Classes/structstr_payload/#variable-flag","text":"char flag;","title":"variable flag"},{"location":"Gateway/Classes/structstr_payload/#variable-sensorval","text":"byte sensorVal;","title":"variable sensorVal"},{"location":"Gateway/Classes/structstr_payload/#variable-rssi","text":"int RSSI;","title":"variable RSSI"},{"location":"Gateway/Classes/structstr_payload/#variable-snr","text":"float SNR; Updated on 2022-08-25 at 10:49:38 +0000","title":"variable SNR"},{"location":"Gateway/Examples/","text":"Examples Updated on 2022-08-25 at 10:49:38 +0000","title":"Examples"},{"location":"Gateway/Examples/#examples","text":"Updated on 2022-08-25 at 10:49:38 +0000","title":"Examples"},{"location":"Gateway/Files/","text":"Files file comms_protocol.cpp Communication Protocol library - set of functions and data structures used to build a network using the LoRa modulation radios. file comms_protocol.h Header file for the communication protocol library. Contains the used data structures, function declaration and general configuartion options for the library. file gateway_serial.ino Gateway script - send sensor data to gateway and receive commands from gateway. Updated on 2022-08-25 at 10:49:38 +0000","title":"Files"},{"location":"Gateway/Files/#files","text":"file comms_protocol.cpp Communication Protocol library - set of functions and data structures used to build a network using the LoRa modulation radios. file comms_protocol.h Header file for the communication protocol library. Contains the used data structures, function declaration and general configuartion options for the library. file gateway_serial.ino Gateway script - send sensor data to gateway and receive commands from gateway. Updated on 2022-08-25 at 10:49:38 +0000","title":"Files"},{"location":"Gateway/Files/comms__protocol_8cpp/","text":"comms_protocol.cpp Communication Protocol library - set of functions and data structures used to build a network using the LoRa modulation radios. More... Functions Name cppQueue msg_q (sizeof( Msg ) , MAX_QUEUE_SIZE , IMPLEMENTATION ) void LoRa_rxMode () Sets the LoRa radio to receive mode. void LoRa_txMode () Sets the LoRa radio to transmit mode. void LoRa_sendMessage (byte * message) Sets the radio to transmit mode, sends a message string using the LoRa radio and sets the radio back to receive mode. byte * splitAndEncrypt2 (char msg[MAX_PAYLOAD_SIZE]) Encrypts a message (character array) using the AES256 algorythm with the corresponding node key The encryption is made by encrypting blocks of 16 bytes and joining them together. char * decryptMsg2 (char msg[MAX_PAYLOAD_SIZE+1]) Decrypts a message string using the AES256 algorythm with the corresponding node key. int mymin (int a, int b) returns the minimum value between two integers void sendAck (byte msgID) Send an acknowledge message confirming the reception of an uplink transmission. void sendStatus (byte msgID) Send an uplink message containing the node status. void setActState (int ID, int val) Sets the state of the relevant actuator with the relevant value. void sendSensorData (byte sensorID, byte sensorVal) Adds to the message queue an uplink message containing sensor data. void getMsgFromQueueAndSend (unsigned long currentMillis) Get a message from the send queue and send it. Implements retransmission in case an acknowledge message is not received. Aware of a failed transmission. void onReceive (int packetSize) Called every time a new message is received. Filters unwanted messages, decrypts the payload, gets the relevant fields from the payload and sends back an acknowledge message if necessary. Attributes Name int currMsg int count unsigned long prevMil unsigned long prevMilSU float VBAT int msgCount aes256_context ctxt Detailed Description Communication Protocol library - set of functions and data structures used to build a network using the LoRa modulation radios. Author : Francisco Santos ( francisco.velez@tecnico.ulisboa.pt ) Version : 1.0 Date : 2022-08-10 Copyright : Copyright (c) 2022 Functions Documentation function msg_q cppQueue msg_q( sizeof(Msg) , MAX_QUEUE_SIZE , IMPLEMENTATION ) function LoRa_rxMode void LoRa_rxMode() Sets the LoRa radio to receive mode. Return : void function LoRa_txMode void LoRa_txMode() Sets the LoRa radio to transmit mode. Return : void function LoRa_sendMessage void LoRa_sendMessage( byte * message ) Sets the radio to transmit mode, sends a message string using the LoRa radio and sets the radio back to receive mode. Parameters : message message to send Return : void function splitAndEncrypt2 byte * splitAndEncrypt2( char msg[MAX_PAYLOAD_SIZE] ) Encrypts a message (character array) using the AES256 algorythm with the corresponding node key The encryption is made by encrypting blocks of 16 bytes and joining them together. Parameters : msg message array to be decrypted Return : byte* a byte array containing the encrypted message function decryptMsg2 char * decryptMsg2( char msg[MAX_PAYLOAD_SIZE+1] ) Decrypts a message string using the AES256 algorythm with the corresponding node key. Parameters : msg message string to be decrypted Return : char* an array of characters containing the decrypted message function mymin int mymin( int a, int b ) returns the minimum value between two integers Parameters : a first integer to compare b second integer to compare Return : int the smaller between a and b function sendAck void sendAck( byte msgID ) Send an acknowledge message confirming the reception of an uplink transmission. Parameters : msgID ID of the message being acknowledged Return : void function sendStatus void sendStatus( byte msgID ) Send an uplink message containing the node status. Parameters : msgID ID of the status request message Return : void function setActState void setActState( int ID, int val ) Sets the state of the relevant actuator with the relevant value. Parameters : ID ID of the relevant actuator val value to which the actuator is set to Return : void function sendSensorData void sendSensorData( byte sensorID, byte sensorVal ) Adds to the message queue an uplink message containing sensor data. Parameters : sensorID ID of the relevant sensor sensorVal value read from the relevant sensor Return : void Note: The ADC value is a 12-bit number, so the maximum value is 4095 (counting from 0). To convert the ADC integer value to a real voltage you\u2019ll need to divide it by the maximum value of 4095, then double it (note above that Adafruit halves the voltage), then multiply that by the reference voltage of the ESP32 which is 3.3V and then vinally, multiply that again by the ADC Reference Voltage of 1100mV. function getMsgFromQueueAndSend void getMsgFromQueueAndSend( unsigned long currentMillis ) Get a message from the send queue and send it. Implements retransmission in case an acknowledge message is not received. Aware of a failed transmission. Parameters : currentMillis current time in millisenconds since boot Return : void function onReceive void onReceive( int packetSize ) Called every time a new message is received. Filters unwanted messages, decrypts the payload, gets the relevant fields from the payload and sends back an acknowledge message if necessary. Parameters : packetSize size of the incoming message in bytes Return : void Attributes Documentation variable currMsg int currMsg = -1; variable count int count = 0; variable prevMil unsigned long prevMil; variable prevMilSU unsigned long prevMilSU; variable VBAT float VBAT = 1.0; variable msgCount int msgCount = 0; variable ctxt aes256_context ctxt; Source code #include \"comms_protocol.h\" int currMsg = -1; int count = 0; unsigned long prevMil; unsigned long prevMilSU; float VBAT = 1.0; int msgCount = 0; cppQueue msg_q(sizeof(Msg), MAX_QUEUE_SIZE, IMPLEMENTATION); aes256_context ctxt; void LoRa_rxMode() { LoRa.enableInvertIQ(); LoRa.receive(); } void LoRa_txMode() { LoRa.idle(); LoRa.disableInvertIQ(); } void LoRa_sendMessage(byte *message) { LoRa_txMode(); // set tx mode LoRa.beginPacket(); // start packet LoRa.write(netID); LoRa.write(nodeID); //LoRa.print(message); // add payload LoRa.write(message, MAX_ENC_PAYLOAD_SIZE); LoRa.endPacket(false); // finish packet and send it LoRa_rxMode(); } /*String splitAndEncrypt(char msg[MAX_PAYLOAD_SIZE]) { String enc = \"\"; aes256_init(&ctxt,(uint8_t *) key); const char * p = msg; while (strlen (p) > 0) { byte plain [BLOCK_SIZE]; memset (plain, 0, BLOCK_SIZE); // ensure trailing zeros memcpy (plain, p, mymin (strlen (p), BLOCK_SIZE)); aes256_encrypt_ecb(&ctxt, plain); enc += String((char *)plain); p += mymin (strlen (p), BLOCK_SIZE); } aes256_done(&ctxt); return enc; }*/ byte *splitAndEncrypt2(char msg[MAX_PAYLOAD_SIZE]) { String enc = \"\"; aes256_init(&ctxt,(uint8_t *) key); const char * p = msg; static byte plain [BLOCK_SIZE]; while (strlen (p) > 0) { memset (plain, 0, BLOCK_SIZE); // ensure trailing zeros memcpy (plain, p, mymin (strlen (p), BLOCK_SIZE)); aes256_encrypt_ecb(&ctxt, plain); return plain; enc += String((char *)plain); p += mymin (strlen (p), BLOCK_SIZE); } aes256_done(&ctxt); } /* * Function: decryptMsg * ---------------------------- * Decrypts a message string using the AES256 algorythm with the corresponding node key * * msg: message string to be decrypted * * returns: an array of characters containing the decrypted message char *decryptMsg(String msg) { static uint8_t data[MAX_PAYLOAD_SIZE+1]; static char m[MAX_PAYLOAD_SIZE+1]; msg.toCharArray(m, MAX_PAYLOAD_SIZE+1); aes256_decrypt_ecb(&ctxt, (uint8_t *)m); return (char *)m; }*/ char *decryptMsg2(char msg[MAX_PAYLOAD_SIZE+1]) { static uint8_t data[MAX_PAYLOAD_SIZE+1]; memcpy(data, msg, MAX_PAYLOAD_SIZE+1); //static char m[MAX_PAYLOAD_SIZE+1]; //msg.toCharArray(m, MAX_PAYLOAD_SIZE+1); aes256_decrypt_ecb(&ctxt, (uint8_t *)data); return (char *)data; } int mymin(int a, int b){ if (a>b) return b; return a; } void sendAck(byte msgID) { String enc; char payload[MAX_PAYLOAD_SIZE]; char encP[MAX_ENC_PAYLOAD_SIZE]; byte l = (byte)MAX_PAYLOAD_SIZE; Msg msg; #if defined(ESP32) VBAT = (float)(analogRead(vbatPin)) / 4095*2*3.3*1.1; #endif int a = VBAT; int b = VBAT*10-a*10; sprintf(payload, \"%c%c%c%c%c%c%c%c\", (char)nodeID, (char)msgID, (char)l, 'a', (char)48, (char)48, (char)a+1, (char)b+1); //enc = splitAndEncrypt(payload); //enc.toCharArray(msg.msg, MAX_ENC_PAYLOAD_SIZE); byte *plain = splitAndEncrypt2(payload); memcpy(msg.msg, plain, MAX_PAYLOAD_SIZE); msg.msg[MAX_PAYLOAD_SIZE] = '\\0'; Serial.print(\"add ack to queue: \"); Serial.println(payload); //Serial.print(\"enc msg: \"); //Serial.println(msg.msg); msg.msgID = msgID; msg.flag = 'a'; msg_q.push(&msg); } void sendStatus(byte msgID) { Msg msg; String enc; char payload[MAX_PAYLOAD_SIZE]; msg.msgID = msgID; byte l = (byte) MAX_PAYLOAD_SIZE; #if defined(ESP32) VBAT = (float)(analogRead(vbatPin)) / 4095*2*3.3*1.1; #endif int a = VBAT; int b = VBAT*10-a*10; sprintf(payload, \"%c%c%c%c%c%c%c%c\", (char)nodeID, (char)msgID, (char)l, 's', (char)48, (char)48, (char)a+1, (char)b+1); //enc = splitAndEncrypt(payload); //enc.toCharArray(msg.msg, MAX_ENC_PAYLOAD_SIZE); byte *plain = splitAndEncrypt2(payload); memcpy(msg.msg, plain, MAX_PAYLOAD_SIZE); msg.msg[MAX_PAYLOAD_SIZE] = '\\0'; Serial.print(\"add status to queue: \"); Serial.println(payload); //Serial.print(\"enc msg: \"); //Serial.println(msg.msg); // Add msg to msg queue msg.flag = 's'; msg_q.push(&msg); } void setActState(int ID, int val) { Serial.print(\"Set actuator: \"); Serial.print(ID); Serial.print(\" with value: \"); Serial.println(val); digitalWrite(actPin[ID], val); } void sendSensorData(byte sensorID, byte sensorVal) { Msg msg; String enc; char payload[MAX_PAYLOAD_SIZE]; msgCount ++; if (msgCount == 0) msgCount ++; msg.msgID = (byte) msgCount; byte l = MAX_PAYLOAD_SIZE; #if defined(ESP32) VBAT = (float)(analogRead(vbatPin)) / 4095*2*3.3*1.1; #endif Serial.println(VBAT); int a = VBAT; int b = VBAT*10-a*10; sprintf(payload, \"%c%c%c%c%c%c%c%c\", (char)nodeID, (char)msg.msgID, (char)l, 'u', (char)(sensorID + 1), (char)(sensorVal + 1), (char)a+1, (char)b+1); //enc = splitAndEncrypt(payload); //enc.toCharArray(msg.msg, MAX_ENC_PAYLOAD_SIZE); byte *plain = splitAndEncrypt2(payload); memcpy(msg.msg, plain, MAX_PAYLOAD_SIZE); msg.msg[MAX_PAYLOAD_SIZE] = '\\0'; // Add msg to msg queue msg.flag = 'u'; msg_q.push(&msg); } void getMsgFromQueueAndSend(unsigned long currentMillis) { if (!msg_q.isEmpty()) { Msg msg; msg_q.peek(&msg); if (currMsg == msg.msgID) count ++; else count = 0; currMsg = msg.msgID; if (count < MAX_N_RETRY) { Serial.print(\"send msg: \"); //Serial.println(msg.msg); LoRa_sendMessage(msg.msg); if ((msg.flag == 's') || (msg.flag == 'a')){ msg_q.drop(); currMsg = -1; } } else { Serial.print(\"Failed to send msg with id: \"); Serial.println(msg.msgID); msg_q.drop(); currMsg = -1; } prevMil = currentMillis; } } void onReceive(int packetSize){ byte rNetID = LoRa.read(); byte rnID = LoRa.read(); char buffer1[MAX_ENC_PAYLOAD_SIZE]; char buffer2[MAX_ENC_PAYLOAD_SIZE]; String message = \"\"; int i=0; while (LoRa.available() && i<MAX_ENC_PAYLOAD_SIZE) { //Serial.println(LoRa.peek(), HEX); buffer1[i] = (char)LoRa.read(); //message += (char)LoRa.read(); i++; } Serial.println(\"msg\"); //Serial.println(message.length()); //Serial.println(MAX_ENC_PAYLOAD_SIZE); //Serial.println(rNetID == netID); if (rNetID == netID) { Serial.println(\"New msg received\"); //int j = message.length() / ENC_BLOCK_SIZE; //int h = message.length() / (1 * j); byte len; Payload p; if (rnID == BROADCAST_ID) aes256_init(&ctxt,(uint8_t *) keyBroadcast); else aes256_init(&ctxt,(uint8_t *) key); //for (int i = 0; i < j; i++) { // if (i == 0) // strcpy(buffer1, decryptMsg(message.substring(i * ENC_BLOCK_SIZE, (i + 1) * ENC_BLOCK_SIZE))); // else // strcat(buffer1, decryptMsg(message.substring(i * ENC_BLOCK_SIZE, (i + 1) * ENC_BLOCK_SIZE))); //} strcpy(buffer2, decryptMsg2(buffer1)); aes256_done(&ctxt); buffer2[6] = '\\0'; Serial.println(buffer2); if(sscanf(buffer2, \"%c%c%c%c%c%c\", &p.nodeID, &p.msgID, &len, &p.flag, &p.sensorID, &p.sensorVal) == 6){ Serial.println(p.flag); Msg msg; msg_q.peek(&msg); if (p.nodeID == nodeID || p.nodeID == BROADCAST_ID) { if (p.flag == 'a') { if (p.msgID == msg.msgID) { Serial.print(\"Message with ID: \"); Serial.print(p.msgID); Serial.println(\" delivered!\"); msg_q.drop(); } } else if (p.flag == 's') { Serial.print(\"received msg with id: \"); Serial.println(p.msgID); sendStatus(p.msgID); } else if (p.flag == 'c') { // Set actuator value and send ack setActState((int)(p.sensorID - 1), (int)(p.sensorVal - 1)); sendAck(p.msgID); } } } } } Updated on 2022-08-25 at 10:49:38 +0000","title":"comms_protocol.cpp"},{"location":"Gateway/Files/comms__protocol_8cpp/#comms_protocolcpp","text":"Communication Protocol library - set of functions and data structures used to build a network using the LoRa modulation radios. More...","title":"comms_protocol.cpp"},{"location":"Gateway/Files/comms__protocol_8cpp/#functions","text":"Name cppQueue msg_q (sizeof( Msg ) , MAX_QUEUE_SIZE , IMPLEMENTATION ) void LoRa_rxMode () Sets the LoRa radio to receive mode. void LoRa_txMode () Sets the LoRa radio to transmit mode. void LoRa_sendMessage (byte * message) Sets the radio to transmit mode, sends a message string using the LoRa radio and sets the radio back to receive mode. byte * splitAndEncrypt2 (char msg[MAX_PAYLOAD_SIZE]) Encrypts a message (character array) using the AES256 algorythm with the corresponding node key The encryption is made by encrypting blocks of 16 bytes and joining them together. char * decryptMsg2 (char msg[MAX_PAYLOAD_SIZE+1]) Decrypts a message string using the AES256 algorythm with the corresponding node key. int mymin (int a, int b) returns the minimum value between two integers void sendAck (byte msgID) Send an acknowledge message confirming the reception of an uplink transmission. void sendStatus (byte msgID) Send an uplink message containing the node status. void setActState (int ID, int val) Sets the state of the relevant actuator with the relevant value. void sendSensorData (byte sensorID, byte sensorVal) Adds to the message queue an uplink message containing sensor data. void getMsgFromQueueAndSend (unsigned long currentMillis) Get a message from the send queue and send it. Implements retransmission in case an acknowledge message is not received. Aware of a failed transmission. void onReceive (int packetSize) Called every time a new message is received. Filters unwanted messages, decrypts the payload, gets the relevant fields from the payload and sends back an acknowledge message if necessary.","title":"Functions"},{"location":"Gateway/Files/comms__protocol_8cpp/#attributes","text":"Name int currMsg int count unsigned long prevMil unsigned long prevMilSU float VBAT int msgCount aes256_context ctxt","title":"Attributes"},{"location":"Gateway/Files/comms__protocol_8cpp/#detailed-description","text":"Communication Protocol library - set of functions and data structures used to build a network using the LoRa modulation radios. Author : Francisco Santos ( francisco.velez@tecnico.ulisboa.pt ) Version : 1.0 Date : 2022-08-10 Copyright : Copyright (c) 2022","title":"Detailed Description"},{"location":"Gateway/Files/comms__protocol_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Gateway/Files/comms__protocol_8cpp/#function-msg_q","text":"cppQueue msg_q( sizeof(Msg) , MAX_QUEUE_SIZE , IMPLEMENTATION )","title":"function msg_q"},{"location":"Gateway/Files/comms__protocol_8cpp/#function-lora_rxmode","text":"void LoRa_rxMode() Sets the LoRa radio to receive mode. Return : void","title":"function LoRa_rxMode"},{"location":"Gateway/Files/comms__protocol_8cpp/#function-lora_txmode","text":"void LoRa_txMode() Sets the LoRa radio to transmit mode. Return : void","title":"function LoRa_txMode"},{"location":"Gateway/Files/comms__protocol_8cpp/#function-lora_sendmessage","text":"void LoRa_sendMessage( byte * message ) Sets the radio to transmit mode, sends a message string using the LoRa radio and sets the radio back to receive mode. Parameters : message message to send Return : void","title":"function LoRa_sendMessage"},{"location":"Gateway/Files/comms__protocol_8cpp/#function-splitandencrypt2","text":"byte * splitAndEncrypt2( char msg[MAX_PAYLOAD_SIZE] ) Encrypts a message (character array) using the AES256 algorythm with the corresponding node key The encryption is made by encrypting blocks of 16 bytes and joining them together. Parameters : msg message array to be decrypted Return : byte* a byte array containing the encrypted message","title":"function splitAndEncrypt2"},{"location":"Gateway/Files/comms__protocol_8cpp/#function-decryptmsg2","text":"char * decryptMsg2( char msg[MAX_PAYLOAD_SIZE+1] ) Decrypts a message string using the AES256 algorythm with the corresponding node key. Parameters : msg message string to be decrypted Return : char* an array of characters containing the decrypted message","title":"function decryptMsg2"},{"location":"Gateway/Files/comms__protocol_8cpp/#function-mymin","text":"int mymin( int a, int b ) returns the minimum value between two integers Parameters : a first integer to compare b second integer to compare Return : int the smaller between a and b","title":"function mymin"},{"location":"Gateway/Files/comms__protocol_8cpp/#function-sendack","text":"void sendAck( byte msgID ) Send an acknowledge message confirming the reception of an uplink transmission. Parameters : msgID ID of the message being acknowledged Return : void","title":"function sendAck"},{"location":"Gateway/Files/comms__protocol_8cpp/#function-sendstatus","text":"void sendStatus( byte msgID ) Send an uplink message containing the node status. Parameters : msgID ID of the status request message Return : void","title":"function sendStatus"},{"location":"Gateway/Files/comms__protocol_8cpp/#function-setactstate","text":"void setActState( int ID, int val ) Sets the state of the relevant actuator with the relevant value. Parameters : ID ID of the relevant actuator val value to which the actuator is set to Return : void","title":"function setActState"},{"location":"Gateway/Files/comms__protocol_8cpp/#function-sendsensordata","text":"void sendSensorData( byte sensorID, byte sensorVal ) Adds to the message queue an uplink message containing sensor data. Parameters : sensorID ID of the relevant sensor sensorVal value read from the relevant sensor Return : void Note: The ADC value is a 12-bit number, so the maximum value is 4095 (counting from 0). To convert the ADC integer value to a real voltage you\u2019ll need to divide it by the maximum value of 4095, then double it (note above that Adafruit halves the voltage), then multiply that by the reference voltage of the ESP32 which is 3.3V and then vinally, multiply that again by the ADC Reference Voltage of 1100mV.","title":"function sendSensorData"},{"location":"Gateway/Files/comms__protocol_8cpp/#function-getmsgfromqueueandsend","text":"void getMsgFromQueueAndSend( unsigned long currentMillis ) Get a message from the send queue and send it. Implements retransmission in case an acknowledge message is not received. Aware of a failed transmission. Parameters : currentMillis current time in millisenconds since boot Return : void","title":"function getMsgFromQueueAndSend"},{"location":"Gateway/Files/comms__protocol_8cpp/#function-onreceive","text":"void onReceive( int packetSize ) Called every time a new message is received. Filters unwanted messages, decrypts the payload, gets the relevant fields from the payload and sends back an acknowledge message if necessary. Parameters : packetSize size of the incoming message in bytes Return : void","title":"function onReceive"},{"location":"Gateway/Files/comms__protocol_8cpp/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Gateway/Files/comms__protocol_8cpp/#variable-currmsg","text":"int currMsg = -1;","title":"variable currMsg"},{"location":"Gateway/Files/comms__protocol_8cpp/#variable-count","text":"int count = 0;","title":"variable count"},{"location":"Gateway/Files/comms__protocol_8cpp/#variable-prevmil","text":"unsigned long prevMil;","title":"variable prevMil"},{"location":"Gateway/Files/comms__protocol_8cpp/#variable-prevmilsu","text":"unsigned long prevMilSU;","title":"variable prevMilSU"},{"location":"Gateway/Files/comms__protocol_8cpp/#variable-vbat","text":"float VBAT = 1.0;","title":"variable VBAT"},{"location":"Gateway/Files/comms__protocol_8cpp/#variable-msgcount","text":"int msgCount = 0;","title":"variable msgCount"},{"location":"Gateway/Files/comms__protocol_8cpp/#variable-ctxt","text":"aes256_context ctxt;","title":"variable ctxt"},{"location":"Gateway/Files/comms__protocol_8cpp/#source-code","text":"#include \"comms_protocol.h\" int currMsg = -1; int count = 0; unsigned long prevMil; unsigned long prevMilSU; float VBAT = 1.0; int msgCount = 0; cppQueue msg_q(sizeof(Msg), MAX_QUEUE_SIZE, IMPLEMENTATION); aes256_context ctxt; void LoRa_rxMode() { LoRa.enableInvertIQ(); LoRa.receive(); } void LoRa_txMode() { LoRa.idle(); LoRa.disableInvertIQ(); } void LoRa_sendMessage(byte *message) { LoRa_txMode(); // set tx mode LoRa.beginPacket(); // start packet LoRa.write(netID); LoRa.write(nodeID); //LoRa.print(message); // add payload LoRa.write(message, MAX_ENC_PAYLOAD_SIZE); LoRa.endPacket(false); // finish packet and send it LoRa_rxMode(); } /*String splitAndEncrypt(char msg[MAX_PAYLOAD_SIZE]) { String enc = \"\"; aes256_init(&ctxt,(uint8_t *) key); const char * p = msg; while (strlen (p) > 0) { byte plain [BLOCK_SIZE]; memset (plain, 0, BLOCK_SIZE); // ensure trailing zeros memcpy (plain, p, mymin (strlen (p), BLOCK_SIZE)); aes256_encrypt_ecb(&ctxt, plain); enc += String((char *)plain); p += mymin (strlen (p), BLOCK_SIZE); } aes256_done(&ctxt); return enc; }*/ byte *splitAndEncrypt2(char msg[MAX_PAYLOAD_SIZE]) { String enc = \"\"; aes256_init(&ctxt,(uint8_t *) key); const char * p = msg; static byte plain [BLOCK_SIZE]; while (strlen (p) > 0) { memset (plain, 0, BLOCK_SIZE); // ensure trailing zeros memcpy (plain, p, mymin (strlen (p), BLOCK_SIZE)); aes256_encrypt_ecb(&ctxt, plain); return plain; enc += String((char *)plain); p += mymin (strlen (p), BLOCK_SIZE); } aes256_done(&ctxt); } /* * Function: decryptMsg * ---------------------------- * Decrypts a message string using the AES256 algorythm with the corresponding node key * * msg: message string to be decrypted * * returns: an array of characters containing the decrypted message char *decryptMsg(String msg) { static uint8_t data[MAX_PAYLOAD_SIZE+1]; static char m[MAX_PAYLOAD_SIZE+1]; msg.toCharArray(m, MAX_PAYLOAD_SIZE+1); aes256_decrypt_ecb(&ctxt, (uint8_t *)m); return (char *)m; }*/ char *decryptMsg2(char msg[MAX_PAYLOAD_SIZE+1]) { static uint8_t data[MAX_PAYLOAD_SIZE+1]; memcpy(data, msg, MAX_PAYLOAD_SIZE+1); //static char m[MAX_PAYLOAD_SIZE+1]; //msg.toCharArray(m, MAX_PAYLOAD_SIZE+1); aes256_decrypt_ecb(&ctxt, (uint8_t *)data); return (char *)data; } int mymin(int a, int b){ if (a>b) return b; return a; } void sendAck(byte msgID) { String enc; char payload[MAX_PAYLOAD_SIZE]; char encP[MAX_ENC_PAYLOAD_SIZE]; byte l = (byte)MAX_PAYLOAD_SIZE; Msg msg; #if defined(ESP32) VBAT = (float)(analogRead(vbatPin)) / 4095*2*3.3*1.1; #endif int a = VBAT; int b = VBAT*10-a*10; sprintf(payload, \"%c%c%c%c%c%c%c%c\", (char)nodeID, (char)msgID, (char)l, 'a', (char)48, (char)48, (char)a+1, (char)b+1); //enc = splitAndEncrypt(payload); //enc.toCharArray(msg.msg, MAX_ENC_PAYLOAD_SIZE); byte *plain = splitAndEncrypt2(payload); memcpy(msg.msg, plain, MAX_PAYLOAD_SIZE); msg.msg[MAX_PAYLOAD_SIZE] = '\\0'; Serial.print(\"add ack to queue: \"); Serial.println(payload); //Serial.print(\"enc msg: \"); //Serial.println(msg.msg); msg.msgID = msgID; msg.flag = 'a'; msg_q.push(&msg); } void sendStatus(byte msgID) { Msg msg; String enc; char payload[MAX_PAYLOAD_SIZE]; msg.msgID = msgID; byte l = (byte) MAX_PAYLOAD_SIZE; #if defined(ESP32) VBAT = (float)(analogRead(vbatPin)) / 4095*2*3.3*1.1; #endif int a = VBAT; int b = VBAT*10-a*10; sprintf(payload, \"%c%c%c%c%c%c%c%c\", (char)nodeID, (char)msgID, (char)l, 's', (char)48, (char)48, (char)a+1, (char)b+1); //enc = splitAndEncrypt(payload); //enc.toCharArray(msg.msg, MAX_ENC_PAYLOAD_SIZE); byte *plain = splitAndEncrypt2(payload); memcpy(msg.msg, plain, MAX_PAYLOAD_SIZE); msg.msg[MAX_PAYLOAD_SIZE] = '\\0'; Serial.print(\"add status to queue: \"); Serial.println(payload); //Serial.print(\"enc msg: \"); //Serial.println(msg.msg); // Add msg to msg queue msg.flag = 's'; msg_q.push(&msg); } void setActState(int ID, int val) { Serial.print(\"Set actuator: \"); Serial.print(ID); Serial.print(\" with value: \"); Serial.println(val); digitalWrite(actPin[ID], val); } void sendSensorData(byte sensorID, byte sensorVal) { Msg msg; String enc; char payload[MAX_PAYLOAD_SIZE]; msgCount ++; if (msgCount == 0) msgCount ++; msg.msgID = (byte) msgCount; byte l = MAX_PAYLOAD_SIZE; #if defined(ESP32) VBAT = (float)(analogRead(vbatPin)) / 4095*2*3.3*1.1; #endif Serial.println(VBAT); int a = VBAT; int b = VBAT*10-a*10; sprintf(payload, \"%c%c%c%c%c%c%c%c\", (char)nodeID, (char)msg.msgID, (char)l, 'u', (char)(sensorID + 1), (char)(sensorVal + 1), (char)a+1, (char)b+1); //enc = splitAndEncrypt(payload); //enc.toCharArray(msg.msg, MAX_ENC_PAYLOAD_SIZE); byte *plain = splitAndEncrypt2(payload); memcpy(msg.msg, plain, MAX_PAYLOAD_SIZE); msg.msg[MAX_PAYLOAD_SIZE] = '\\0'; // Add msg to msg queue msg.flag = 'u'; msg_q.push(&msg); } void getMsgFromQueueAndSend(unsigned long currentMillis) { if (!msg_q.isEmpty()) { Msg msg; msg_q.peek(&msg); if (currMsg == msg.msgID) count ++; else count = 0; currMsg = msg.msgID; if (count < MAX_N_RETRY) { Serial.print(\"send msg: \"); //Serial.println(msg.msg); LoRa_sendMessage(msg.msg); if ((msg.flag == 's') || (msg.flag == 'a')){ msg_q.drop(); currMsg = -1; } } else { Serial.print(\"Failed to send msg with id: \"); Serial.println(msg.msgID); msg_q.drop(); currMsg = -1; } prevMil = currentMillis; } } void onReceive(int packetSize){ byte rNetID = LoRa.read(); byte rnID = LoRa.read(); char buffer1[MAX_ENC_PAYLOAD_SIZE]; char buffer2[MAX_ENC_PAYLOAD_SIZE]; String message = \"\"; int i=0; while (LoRa.available() && i<MAX_ENC_PAYLOAD_SIZE) { //Serial.println(LoRa.peek(), HEX); buffer1[i] = (char)LoRa.read(); //message += (char)LoRa.read(); i++; } Serial.println(\"msg\"); //Serial.println(message.length()); //Serial.println(MAX_ENC_PAYLOAD_SIZE); //Serial.println(rNetID == netID); if (rNetID == netID) { Serial.println(\"New msg received\"); //int j = message.length() / ENC_BLOCK_SIZE; //int h = message.length() / (1 * j); byte len; Payload p; if (rnID == BROADCAST_ID) aes256_init(&ctxt,(uint8_t *) keyBroadcast); else aes256_init(&ctxt,(uint8_t *) key); //for (int i = 0; i < j; i++) { // if (i == 0) // strcpy(buffer1, decryptMsg(message.substring(i * ENC_BLOCK_SIZE, (i + 1) * ENC_BLOCK_SIZE))); // else // strcat(buffer1, decryptMsg(message.substring(i * ENC_BLOCK_SIZE, (i + 1) * ENC_BLOCK_SIZE))); //} strcpy(buffer2, decryptMsg2(buffer1)); aes256_done(&ctxt); buffer2[6] = '\\0'; Serial.println(buffer2); if(sscanf(buffer2, \"%c%c%c%c%c%c\", &p.nodeID, &p.msgID, &len, &p.flag, &p.sensorID, &p.sensorVal) == 6){ Serial.println(p.flag); Msg msg; msg_q.peek(&msg); if (p.nodeID == nodeID || p.nodeID == BROADCAST_ID) { if (p.flag == 'a') { if (p.msgID == msg.msgID) { Serial.print(\"Message with ID: \"); Serial.print(p.msgID); Serial.println(\" delivered!\"); msg_q.drop(); } } else if (p.flag == 's') { Serial.print(\"received msg with id: \"); Serial.println(p.msgID); sendStatus(p.msgID); } else if (p.flag == 'c') { // Set actuator value and send ack setActState((int)(p.sensorID - 1), (int)(p.sensorVal - 1)); sendAck(p.msgID); } } } } } Updated on 2022-08-25 at 10:49:38 +0000","title":"Source code"},{"location":"Gateway/Files/comms__protocol_8h/","text":"comms_protocol.h Header file for the communication protocol library. Contains the used data structures, function declaration and general configuartion options for the library. More... Classes Name struct strPayload struct strMsg Types Name typedef struct strPayload Payload typedef struct strMsg Msg Functions Name void LoRa_rxMode () Sets the LoRa radio to receive mode. void LoRa_txMode () Sets the LoRa radio to transmit mode. void LoRa_sendMessage (byte * message) Sets the radio to transmit mode, sends a message string using the LoRa radio and sets the radio back to receive mode. char * decryptMsg (String msg) char * decryptMsg2 (char msg[MAX_PAYLOAD_SIZE+1]) Decrypts a message string using the AES256 algorythm with the corresponding node key. void onReceive (int packetSize) Called every time a new message is received. Filters unwanted messages, decrypts the payload, gets the relevant fields from the payload and sends back an acknowledge message if necessary. void onTxDone () String splitAndEncrypt (char msg[MAX_PAYLOAD_SIZE]) void sendSensorData (byte sensorID, byte sensorVal) Adds to the message queue an uplink message containing sensor data. void getMsgFromQueueAndSend (unsigned long currentMillis) Get a message from the send queue and send it. Implements retransmission in case an acknowledge message is not received. Aware of a failed transmission. void sendStatus (byte msgID) Send an uplink message containing the node status. void sendAck (byte msgID) Send an acknowledge message confirming the reception of an uplink transmission. void setActState (int ID, int val) Sets the state of the relevant actuator with the relevant value. int mymin (int a, int b) returns the minimum value between two integers Attributes Name const uint8_t keyBroadcast const long frequency const int txPower const int spreadingFactor const long signalBandwidth const int codingRateDenominator int currMsg int count unsigned long prevMil unsigned long prevMilSU int msgCount cppQueue msg_q aes256_context ctxt Defines Name IMPLEMENTATION MAX_N_RETRY TIMEOUT_INTERVAL MAX_QUEUE_SIZE BLOCK_SIZE MAX_PAYLOAD_SIZE ENC_BLOCK_SIZE MAX_ENC_PAYLOAD_SIZE MAX_MSG_ID STATUS_UPDATE_INTERVAL BROADCAST_ID Detailed Description Header file for the communication protocol library. Contains the used data structures, function declaration and general configuartion options for the library. Author : Francisco Santos ( francisco.velez@tecnico.ulisboa.pt ) Version : 1.0 Date : 2022-08-10 Copyright : Copyright (c) 2022 Types Documentation typedef Payload typedef struct strPayload Payload; typedef Msg typedef struct strMsg Msg; Functions Documentation function LoRa_rxMode void LoRa_rxMode() Sets the LoRa radio to receive mode. Return : void function LoRa_txMode void LoRa_txMode() Sets the LoRa radio to transmit mode. Return : void function LoRa_sendMessage void LoRa_sendMessage( byte * message ) Sets the radio to transmit mode, sends a message string using the LoRa radio and sets the radio back to receive mode. Parameters : message message to send Return : void function decryptMsg char * decryptMsg( String msg ) function decryptMsg2 char * decryptMsg2( char msg[MAX_PAYLOAD_SIZE+1] ) Decrypts a message string using the AES256 algorythm with the corresponding node key. Parameters : msg message string to be decrypted Return : char* an array of characters containing the decrypted message function onReceive void onReceive( int packetSize ) Called every time a new message is received. Filters unwanted messages, decrypts the payload, gets the relevant fields from the payload and sends back an acknowledge message if necessary. Parameters : packetSize size of the incoming message in bytes Return : void function onTxDone void onTxDone() function splitAndEncrypt String splitAndEncrypt( char msg[MAX_PAYLOAD_SIZE] ) function sendSensorData void sendSensorData( byte sensorID, byte sensorVal ) Adds to the message queue an uplink message containing sensor data. Parameters : sensorID ID of the relevant sensor sensorVal value read from the relevant sensor Return : void Note: The ADC value is a 12-bit number, so the maximum value is 4095 (counting from 0). To convert the ADC integer value to a real voltage you\u2019ll need to divide it by the maximum value of 4095, then double it (note above that Adafruit halves the voltage), then multiply that by the reference voltage of the ESP32 which is 3.3V and then vinally, multiply that again by the ADC Reference Voltage of 1100mV. function getMsgFromQueueAndSend void getMsgFromQueueAndSend( unsigned long currentMillis ) Get a message from the send queue and send it. Implements retransmission in case an acknowledge message is not received. Aware of a failed transmission. Parameters : currentMillis current time in millisenconds since boot Return : void function sendStatus void sendStatus( byte msgID ) Send an uplink message containing the node status. Parameters : msgID ID of the status request message Return : void function sendAck void sendAck( byte msgID ) Send an acknowledge message confirming the reception of an uplink transmission. Parameters : msgID ID of the message being acknowledged Return : void function setActState void setActState( int ID, int val ) Sets the state of the relevant actuator with the relevant value. Parameters : ID ID of the relevant actuator val value to which the actuator is set to Return : void function mymin int mymin( int a, int b ) returns the minimum value between two integers Parameters : a first integer to compare b second integer to compare Return : int the smaller between a and b Attributes Documentation variable keyBroadcast const uint8_t keyBroadcast = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x0f }; variable frequency const long frequency = 868E6; variable txPower const int txPower = 14; variable spreadingFactor const int spreadingFactor = 7; variable signalBandwidth const long signalBandwidth = 125E3; variable codingRateDenominator const int codingRateDenominator = 5; variable currMsg int currMsg; variable count int count; variable prevMil unsigned long prevMil; variable prevMilSU unsigned long prevMilSU; variable msgCount int msgCount; variable msg_q cppQueue msg_q; variable ctxt aes256_context ctxt; Macros Documentation define IMPLEMENTATION #define IMPLEMENTATION FIFO define MAX_N_RETRY #define MAX_N_RETRY 3 define TIMEOUT_INTERVAL #define TIMEOUT_INTERVAL 1000 define MAX_QUEUE_SIZE #define MAX_QUEUE_SIZE 5 define BLOCK_SIZE #define BLOCK_SIZE 16 define MAX_PAYLOAD_SIZE #define MAX_PAYLOAD_SIZE 16 define ENC_BLOCK_SIZE #define ENC_BLOCK_SIZE (1*BLOCK_SIZE) define MAX_ENC_PAYLOAD_SIZE #define MAX_ENC_PAYLOAD_SIZE ((MAX_PAYLOAD_SIZE/BLOCK_SIZE)*ENC_BLOCK_SIZE)+1 define MAX_MSG_ID #define MAX_MSG_ID 256 define STATUS_UPDATE_INTERVAL #define STATUS_UPDATE_INTERVAL 60000 define BROADCAST_ID #define BROADCAST_ID 0xFF Source code #ifndef COMMS_PROTOCOL_H #define COMMS_PROTOCOL_H #include <Arduino.h> #include <SPI.h> #include <LoRa.h> #include <cppQueue.h> #include <aes256.h> #include \"node_definitions.h\" #define IMPLEMENTATION FIFO // LoRa msg payload settings #define MAX_N_RETRY 3 #define TIMEOUT_INTERVAL 1000 #define MAX_QUEUE_SIZE 5 #define BLOCK_SIZE 16 #define MAX_PAYLOAD_SIZE 16 #define ENC_BLOCK_SIZE (1*BLOCK_SIZE) #define MAX_ENC_PAYLOAD_SIZE ((MAX_PAYLOAD_SIZE/BLOCK_SIZE)*ENC_BLOCK_SIZE)+1 #define MAX_MSG_ID 256 #define STATUS_UPDATE_INTERVAL 60000 #define BROADCAST_ID 0xFF // Broadcast Encryption key const uint8_t keyBroadcast[] = { // 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x0f }; // LoRa Modem Settings const long frequency = 868E6; const int txPower = 14; const int spreadingFactor = 7; const long signalBandwidth = 125E3; const int codingRateDenominator = 5; typedef struct strPayload { byte nodeID; byte sensorID; byte msgID; char flag; byte sensorVal; int RSSI; float SNR; } Payload; typedef struct strMsg { byte msg[MAX_ENC_PAYLOAD_SIZE]; byte msgID; char flag; } Msg; extern int currMsg; extern int count; extern unsigned long prevMil; extern unsigned long prevMilSU; extern int msgCount; extern cppQueue msg_q; extern aes256_context ctxt; void LoRa_rxMode(); void LoRa_txMode(); void LoRa_sendMessage(byte *message); char *decryptMsg(String msg); char *decryptMsg2(char msg[MAX_PAYLOAD_SIZE+1]); void onReceive(int packetSize); void onTxDone(); String splitAndEncrypt(char msg[MAX_PAYLOAD_SIZE]); void sendSensorData(byte sensorID, byte sensorVal); void getMsgFromQueueAndSend(unsigned long currentMillis); void sendStatus(byte msgID); void sendAck(byte msgID); void setActState(int ID, int val); int mymin(int a, int b); #endif Updated on 2022-08-25 at 10:49:38 +0000","title":"comms_protocol.h"},{"location":"Gateway/Files/comms__protocol_8h/#comms_protocolh","text":"Header file for the communication protocol library. Contains the used data structures, function declaration and general configuartion options for the library. More...","title":"comms_protocol.h"},{"location":"Gateway/Files/comms__protocol_8h/#classes","text":"Name struct strPayload struct strMsg","title":"Classes"},{"location":"Gateway/Files/comms__protocol_8h/#types","text":"Name typedef struct strPayload Payload typedef struct strMsg Msg","title":"Types"},{"location":"Gateway/Files/comms__protocol_8h/#functions","text":"Name void LoRa_rxMode () Sets the LoRa radio to receive mode. void LoRa_txMode () Sets the LoRa radio to transmit mode. void LoRa_sendMessage (byte * message) Sets the radio to transmit mode, sends a message string using the LoRa radio and sets the radio back to receive mode. char * decryptMsg (String msg) char * decryptMsg2 (char msg[MAX_PAYLOAD_SIZE+1]) Decrypts a message string using the AES256 algorythm with the corresponding node key. void onReceive (int packetSize) Called every time a new message is received. Filters unwanted messages, decrypts the payload, gets the relevant fields from the payload and sends back an acknowledge message if necessary. void onTxDone () String splitAndEncrypt (char msg[MAX_PAYLOAD_SIZE]) void sendSensorData (byte sensorID, byte sensorVal) Adds to the message queue an uplink message containing sensor data. void getMsgFromQueueAndSend (unsigned long currentMillis) Get a message from the send queue and send it. Implements retransmission in case an acknowledge message is not received. Aware of a failed transmission. void sendStatus (byte msgID) Send an uplink message containing the node status. void sendAck (byte msgID) Send an acknowledge message confirming the reception of an uplink transmission. void setActState (int ID, int val) Sets the state of the relevant actuator with the relevant value. int mymin (int a, int b) returns the minimum value between two integers","title":"Functions"},{"location":"Gateway/Files/comms__protocol_8h/#attributes","text":"Name const uint8_t keyBroadcast const long frequency const int txPower const int spreadingFactor const long signalBandwidth const int codingRateDenominator int currMsg int count unsigned long prevMil unsigned long prevMilSU int msgCount cppQueue msg_q aes256_context ctxt","title":"Attributes"},{"location":"Gateway/Files/comms__protocol_8h/#defines","text":"Name IMPLEMENTATION MAX_N_RETRY TIMEOUT_INTERVAL MAX_QUEUE_SIZE BLOCK_SIZE MAX_PAYLOAD_SIZE ENC_BLOCK_SIZE MAX_ENC_PAYLOAD_SIZE MAX_MSG_ID STATUS_UPDATE_INTERVAL BROADCAST_ID","title":"Defines"},{"location":"Gateway/Files/comms__protocol_8h/#detailed-description","text":"Header file for the communication protocol library. Contains the used data structures, function declaration and general configuartion options for the library. Author : Francisco Santos ( francisco.velez@tecnico.ulisboa.pt ) Version : 1.0 Date : 2022-08-10 Copyright : Copyright (c) 2022","title":"Detailed Description"},{"location":"Gateway/Files/comms__protocol_8h/#types-documentation","text":"","title":"Types Documentation"},{"location":"Gateway/Files/comms__protocol_8h/#typedef-payload","text":"typedef struct strPayload Payload;","title":"typedef Payload"},{"location":"Gateway/Files/comms__protocol_8h/#typedef-msg","text":"typedef struct strMsg Msg;","title":"typedef Msg"},{"location":"Gateway/Files/comms__protocol_8h/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Gateway/Files/comms__protocol_8h/#function-lora_rxmode","text":"void LoRa_rxMode() Sets the LoRa radio to receive mode. Return : void","title":"function LoRa_rxMode"},{"location":"Gateway/Files/comms__protocol_8h/#function-lora_txmode","text":"void LoRa_txMode() Sets the LoRa radio to transmit mode. Return : void","title":"function LoRa_txMode"},{"location":"Gateway/Files/comms__protocol_8h/#function-lora_sendmessage","text":"void LoRa_sendMessage( byte * message ) Sets the radio to transmit mode, sends a message string using the LoRa radio and sets the radio back to receive mode. Parameters : message message to send Return : void","title":"function LoRa_sendMessage"},{"location":"Gateway/Files/comms__protocol_8h/#function-decryptmsg","text":"char * decryptMsg( String msg )","title":"function decryptMsg"},{"location":"Gateway/Files/comms__protocol_8h/#function-decryptmsg2","text":"char * decryptMsg2( char msg[MAX_PAYLOAD_SIZE+1] ) Decrypts a message string using the AES256 algorythm with the corresponding node key. Parameters : msg message string to be decrypted Return : char* an array of characters containing the decrypted message","title":"function decryptMsg2"},{"location":"Gateway/Files/comms__protocol_8h/#function-onreceive","text":"void onReceive( int packetSize ) Called every time a new message is received. Filters unwanted messages, decrypts the payload, gets the relevant fields from the payload and sends back an acknowledge message if necessary. Parameters : packetSize size of the incoming message in bytes Return : void","title":"function onReceive"},{"location":"Gateway/Files/comms__protocol_8h/#function-ontxdone","text":"void onTxDone()","title":"function onTxDone"},{"location":"Gateway/Files/comms__protocol_8h/#function-splitandencrypt","text":"String splitAndEncrypt( char msg[MAX_PAYLOAD_SIZE] )","title":"function splitAndEncrypt"},{"location":"Gateway/Files/comms__protocol_8h/#function-sendsensordata","text":"void sendSensorData( byte sensorID, byte sensorVal ) Adds to the message queue an uplink message containing sensor data. Parameters : sensorID ID of the relevant sensor sensorVal value read from the relevant sensor Return : void Note: The ADC value is a 12-bit number, so the maximum value is 4095 (counting from 0). To convert the ADC integer value to a real voltage you\u2019ll need to divide it by the maximum value of 4095, then double it (note above that Adafruit halves the voltage), then multiply that by the reference voltage of the ESP32 which is 3.3V and then vinally, multiply that again by the ADC Reference Voltage of 1100mV.","title":"function sendSensorData"},{"location":"Gateway/Files/comms__protocol_8h/#function-getmsgfromqueueandsend","text":"void getMsgFromQueueAndSend( unsigned long currentMillis ) Get a message from the send queue and send it. Implements retransmission in case an acknowledge message is not received. Aware of a failed transmission. Parameters : currentMillis current time in millisenconds since boot Return : void","title":"function getMsgFromQueueAndSend"},{"location":"Gateway/Files/comms__protocol_8h/#function-sendstatus","text":"void sendStatus( byte msgID ) Send an uplink message containing the node status. Parameters : msgID ID of the status request message Return : void","title":"function sendStatus"},{"location":"Gateway/Files/comms__protocol_8h/#function-sendack","text":"void sendAck( byte msgID ) Send an acknowledge message confirming the reception of an uplink transmission. Parameters : msgID ID of the message being acknowledged Return : void","title":"function sendAck"},{"location":"Gateway/Files/comms__protocol_8h/#function-setactstate","text":"void setActState( int ID, int val ) Sets the state of the relevant actuator with the relevant value. Parameters : ID ID of the relevant actuator val value to which the actuator is set to Return : void","title":"function setActState"},{"location":"Gateway/Files/comms__protocol_8h/#function-mymin","text":"int mymin( int a, int b ) returns the minimum value between two integers Parameters : a first integer to compare b second integer to compare Return : int the smaller between a and b","title":"function mymin"},{"location":"Gateway/Files/comms__protocol_8h/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Gateway/Files/comms__protocol_8h/#variable-keybroadcast","text":"const uint8_t keyBroadcast = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x0f };","title":"variable keyBroadcast"},{"location":"Gateway/Files/comms__protocol_8h/#variable-frequency","text":"const long frequency = 868E6;","title":"variable frequency"},{"location":"Gateway/Files/comms__protocol_8h/#variable-txpower","text":"const int txPower = 14;","title":"variable txPower"},{"location":"Gateway/Files/comms__protocol_8h/#variable-spreadingfactor","text":"const int spreadingFactor = 7;","title":"variable spreadingFactor"},{"location":"Gateway/Files/comms__protocol_8h/#variable-signalbandwidth","text":"const long signalBandwidth = 125E3;","title":"variable signalBandwidth"},{"location":"Gateway/Files/comms__protocol_8h/#variable-codingratedenominator","text":"const int codingRateDenominator = 5;","title":"variable codingRateDenominator"},{"location":"Gateway/Files/comms__protocol_8h/#variable-currmsg","text":"int currMsg;","title":"variable currMsg"},{"location":"Gateway/Files/comms__protocol_8h/#variable-count","text":"int count;","title":"variable count"},{"location":"Gateway/Files/comms__protocol_8h/#variable-prevmil","text":"unsigned long prevMil;","title":"variable prevMil"},{"location":"Gateway/Files/comms__protocol_8h/#variable-prevmilsu","text":"unsigned long prevMilSU;","title":"variable prevMilSU"},{"location":"Gateway/Files/comms__protocol_8h/#variable-msgcount","text":"int msgCount;","title":"variable msgCount"},{"location":"Gateway/Files/comms__protocol_8h/#variable-msg_q","text":"cppQueue msg_q;","title":"variable msg_q"},{"location":"Gateway/Files/comms__protocol_8h/#variable-ctxt","text":"aes256_context ctxt;","title":"variable ctxt"},{"location":"Gateway/Files/comms__protocol_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"Gateway/Files/comms__protocol_8h/#define-implementation","text":"#define IMPLEMENTATION FIFO","title":"define IMPLEMENTATION"},{"location":"Gateway/Files/comms__protocol_8h/#define-max_n_retry","text":"#define MAX_N_RETRY 3","title":"define MAX_N_RETRY"},{"location":"Gateway/Files/comms__protocol_8h/#define-timeout_interval","text":"#define TIMEOUT_INTERVAL 1000","title":"define TIMEOUT_INTERVAL"},{"location":"Gateway/Files/comms__protocol_8h/#define-max_queue_size","text":"#define MAX_QUEUE_SIZE 5","title":"define MAX_QUEUE_SIZE"},{"location":"Gateway/Files/comms__protocol_8h/#define-block_size","text":"#define BLOCK_SIZE 16","title":"define BLOCK_SIZE"},{"location":"Gateway/Files/comms__protocol_8h/#define-max_payload_size","text":"#define MAX_PAYLOAD_SIZE 16","title":"define MAX_PAYLOAD_SIZE"},{"location":"Gateway/Files/comms__protocol_8h/#define-enc_block_size","text":"#define ENC_BLOCK_SIZE (1*BLOCK_SIZE)","title":"define ENC_BLOCK_SIZE"},{"location":"Gateway/Files/comms__protocol_8h/#define-max_enc_payload_size","text":"#define MAX_ENC_PAYLOAD_SIZE ((MAX_PAYLOAD_SIZE/BLOCK_SIZE)*ENC_BLOCK_SIZE)+1","title":"define MAX_ENC_PAYLOAD_SIZE"},{"location":"Gateway/Files/comms__protocol_8h/#define-max_msg_id","text":"#define MAX_MSG_ID 256","title":"define MAX_MSG_ID"},{"location":"Gateway/Files/comms__protocol_8h/#define-status_update_interval","text":"#define STATUS_UPDATE_INTERVAL 60000","title":"define STATUS_UPDATE_INTERVAL"},{"location":"Gateway/Files/comms__protocol_8h/#define-broadcast_id","text":"#define BROADCAST_ID 0xFF","title":"define BROADCAST_ID"},{"location":"Gateway/Files/comms__protocol_8h/#source-code","text":"#ifndef COMMS_PROTOCOL_H #define COMMS_PROTOCOL_H #include <Arduino.h> #include <SPI.h> #include <LoRa.h> #include <cppQueue.h> #include <aes256.h> #include \"node_definitions.h\" #define IMPLEMENTATION FIFO // LoRa msg payload settings #define MAX_N_RETRY 3 #define TIMEOUT_INTERVAL 1000 #define MAX_QUEUE_SIZE 5 #define BLOCK_SIZE 16 #define MAX_PAYLOAD_SIZE 16 #define ENC_BLOCK_SIZE (1*BLOCK_SIZE) #define MAX_ENC_PAYLOAD_SIZE ((MAX_PAYLOAD_SIZE/BLOCK_SIZE)*ENC_BLOCK_SIZE)+1 #define MAX_MSG_ID 256 #define STATUS_UPDATE_INTERVAL 60000 #define BROADCAST_ID 0xFF // Broadcast Encryption key const uint8_t keyBroadcast[] = { // 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x0f }; // LoRa Modem Settings const long frequency = 868E6; const int txPower = 14; const int spreadingFactor = 7; const long signalBandwidth = 125E3; const int codingRateDenominator = 5; typedef struct strPayload { byte nodeID; byte sensorID; byte msgID; char flag; byte sensorVal; int RSSI; float SNR; } Payload; typedef struct strMsg { byte msg[MAX_ENC_PAYLOAD_SIZE]; byte msgID; char flag; } Msg; extern int currMsg; extern int count; extern unsigned long prevMil; extern unsigned long prevMilSU; extern int msgCount; extern cppQueue msg_q; extern aes256_context ctxt; void LoRa_rxMode(); void LoRa_txMode(); void LoRa_sendMessage(byte *message); char *decryptMsg(String msg); char *decryptMsg2(char msg[MAX_PAYLOAD_SIZE+1]); void onReceive(int packetSize); void onTxDone(); String splitAndEncrypt(char msg[MAX_PAYLOAD_SIZE]); void sendSensorData(byte sensorID, byte sensorVal); void getMsgFromQueueAndSend(unsigned long currentMillis); void sendStatus(byte msgID); void sendAck(byte msgID); void setActState(int ID, int val); int mymin(int a, int b); #endif Updated on 2022-08-25 at 10:49:38 +0000","title":"Source code"},{"location":"Gateway/Files/gateway__serial_8ino/","text":"gateway_serial.ino Gateway script - send sensor data to gateway and receive commands from gateway. More... Functions Name void setup () Arduino setup function. void loop () Arduino loop function. Detailed Description Gateway script - send sensor data to gateway and receive commands from gateway. Author : Francisco Santos ( francisco.velez@tecnico.ulisboa.pt ) Version : 1.0 Date : 2022-08-09 Copyright : Copyright (c) 2022 Functions Documentation function setup void setup() Arduino setup function. Function: setup Runs once at boot. Configure the serial communication. Configure the LoRa radio. Configure the sensors and actuators input mode void function loop void loop() Arduino loop function. Function: loop Main loop function. checks for incoming uplink messages and downlink requests from the server. calls getMsgFromQueueAndSend on fixed schedules to avoid congestion of the communication channel and sends an uplink message with the node status periodically. void Source code #include \"comms_protocol.h\" void setup() { for(int i=0; i<sensN; i++){ pinMode(sensPin[i], INPUT); } for(int i=0; i<actN; i++){ pinMode(actPin[i], OUTPUT); } Serial.begin(BAUD_RATE); #if defined(ESP32) SPI.begin(SCK, MISO, MOSI, SS); #endif //LoRa.setTxPower(txPower); //LoRa.setSignalBandwidth(signalBandwidth); //LoRa.setCodingRate4(codingRateDenominator); LoRa.setPins(SS, RST, DIO0); if (!LoRa.begin(frequency)) { Serial.println(\"LoRa init failed.\"); while (true); } LoRa.setSpreadingFactor(7); LoRa.setCodingRate4(8); LoRa.setSyncWord(netID); LoRa.enableCrc(); LoRa_rxMode(); prevMil = millis(); prevMilSU = millis(); Serial.println(\"Node startup complete\"); sendSensorData(0, 3); } void loop() { unsigned long currentMillis = millis(); // Receive Downlink msg int packetSize = LoRa.parsePacket(); if (packetSize) { onReceive(packetSize); } // Send Uplink msg if((currentMillis-prevMil) > TIMEOUT_INTERVAL){ getMsgFromQueueAndSend(currentMillis); } // Send node status if((currentMillis-prevMilSU) > STATUS_UPDATE_INTERVAL){ byte msgID = random(MAX_MSG_ID); //sendStatus(msgID); prevMilSU = currentMillis; } } Updated on 2022-08-25 at 10:49:38 +0000","title":"gateway_serial.ino"},{"location":"Gateway/Files/gateway__serial_8ino/#gateway_serialino","text":"Gateway script - send sensor data to gateway and receive commands from gateway. More...","title":"gateway_serial.ino"},{"location":"Gateway/Files/gateway__serial_8ino/#functions","text":"Name void setup () Arduino setup function. void loop () Arduino loop function.","title":"Functions"},{"location":"Gateway/Files/gateway__serial_8ino/#detailed-description","text":"Gateway script - send sensor data to gateway and receive commands from gateway. Author : Francisco Santos ( francisco.velez@tecnico.ulisboa.pt ) Version : 1.0 Date : 2022-08-09 Copyright : Copyright (c) 2022","title":"Detailed Description"},{"location":"Gateway/Files/gateway__serial_8ino/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Gateway/Files/gateway__serial_8ino/#function-setup","text":"void setup() Arduino setup function.","title":"function setup"},{"location":"Gateway/Files/gateway__serial_8ino/#function-setup_1","text":"Runs once at boot. Configure the serial communication. Configure the LoRa radio. Configure the sensors and actuators input mode void","title":"Function: setup"},{"location":"Gateway/Files/gateway__serial_8ino/#function-loop","text":"void loop() Arduino loop function.","title":"function loop"},{"location":"Gateway/Files/gateway__serial_8ino/#function-loop_1","text":"Main loop function. checks for incoming uplink messages and downlink requests from the server. calls getMsgFromQueueAndSend on fixed schedules to avoid congestion of the communication channel and sends an uplink message with the node status periodically. void","title":"Function: loop"},{"location":"Gateway/Files/gateway__serial_8ino/#source-code","text":"#include \"comms_protocol.h\" void setup() { for(int i=0; i<sensN; i++){ pinMode(sensPin[i], INPUT); } for(int i=0; i<actN; i++){ pinMode(actPin[i], OUTPUT); } Serial.begin(BAUD_RATE); #if defined(ESP32) SPI.begin(SCK, MISO, MOSI, SS); #endif //LoRa.setTxPower(txPower); //LoRa.setSignalBandwidth(signalBandwidth); //LoRa.setCodingRate4(codingRateDenominator); LoRa.setPins(SS, RST, DIO0); if (!LoRa.begin(frequency)) { Serial.println(\"LoRa init failed.\"); while (true); } LoRa.setSpreadingFactor(7); LoRa.setCodingRate4(8); LoRa.setSyncWord(netID); LoRa.enableCrc(); LoRa_rxMode(); prevMil = millis(); prevMilSU = millis(); Serial.println(\"Node startup complete\"); sendSensorData(0, 3); } void loop() { unsigned long currentMillis = millis(); // Receive Downlink msg int packetSize = LoRa.parsePacket(); if (packetSize) { onReceive(packetSize); } // Send Uplink msg if((currentMillis-prevMil) > TIMEOUT_INTERVAL){ getMsgFromQueueAndSend(currentMillis); } // Send node status if((currentMillis-prevMilSU) > STATUS_UPDATE_INTERVAL){ byte msgID = random(MAX_MSG_ID); //sendStatus(msgID); prevMilSU = currentMillis; } } Updated on 2022-08-25 at 10:49:38 +0000","title":"Source code"},{"location":"Gateway/Modules/","text":"Modules Updated on 2022-08-25 at 10:49:38 +0000","title":"Modules"},{"location":"Gateway/Modules/#modules","text":"Updated on 2022-08-25 at 10:49:38 +0000","title":"Modules"},{"location":"Gateway/Namespaces/","text":"Namespaces Updated on 2022-08-25 at 10:49:38 +0000","title":"Namespaces"},{"location":"Gateway/Namespaces/#namespaces","text":"Updated on 2022-08-25 at 10:49:38 +0000","title":"Namespaces"},{"location":"Gateway/Pages/","text":"Pages Updated on 2022-08-25 at 10:49:38 +0000","title":"Pages"},{"location":"Gateway/Pages/#pages","text":"Updated on 2022-08-25 at 10:49:38 +0000","title":"Pages"},{"location":"Node/Classes/","text":"Classes struct strMsg struct strPayload Updated on 2022-08-25 at 10:49:36 +0000","title":"Classes"},{"location":"Node/Classes/#classes","text":"struct strMsg struct strPayload Updated on 2022-08-25 at 10:49:36 +0000","title":"Classes"},{"location":"Node/Classes/structstr_msg/","text":"strMsg #include <comms_protocol.h> Public Attributes Name byte msg byte msgID char flag Public Attributes Documentation variable msg byte msg; variable msgID byte msgID; variable flag char flag; Updated on 2022-08-25 at 10:49:36 +0000","title":"strMsg"},{"location":"Node/Classes/structstr_msg/#strmsg","text":"#include <comms_protocol.h>","title":"strMsg"},{"location":"Node/Classes/structstr_msg/#public-attributes","text":"Name byte msg byte msgID char flag","title":"Public Attributes"},{"location":"Node/Classes/structstr_msg/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Node/Classes/structstr_msg/#variable-msg","text":"byte msg;","title":"variable msg"},{"location":"Node/Classes/structstr_msg/#variable-msgid","text":"byte msgID;","title":"variable msgID"},{"location":"Node/Classes/structstr_msg/#variable-flag","text":"char flag; Updated on 2022-08-25 at 10:49:36 +0000","title":"variable flag"},{"location":"Node/Classes/structstr_payload/","text":"strPayload #include <comms_protocol.h> Public Attributes Name byte nodeID byte sensorID byte msgID char flag byte sensorVal int RSSI float SNR Public Attributes Documentation variable nodeID byte nodeID; variable sensorID byte sensorID; variable msgID byte msgID; variable flag char flag; variable sensorVal byte sensorVal; variable RSSI int RSSI; variable SNR float SNR; Updated on 2022-08-25 at 10:49:36 +0000","title":"strPayload"},{"location":"Node/Classes/structstr_payload/#strpayload","text":"#include <comms_protocol.h>","title":"strPayload"},{"location":"Node/Classes/structstr_payload/#public-attributes","text":"Name byte nodeID byte sensorID byte msgID char flag byte sensorVal int RSSI float SNR","title":"Public Attributes"},{"location":"Node/Classes/structstr_payload/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Node/Classes/structstr_payload/#variable-nodeid","text":"byte nodeID;","title":"variable nodeID"},{"location":"Node/Classes/structstr_payload/#variable-sensorid","text":"byte sensorID;","title":"variable sensorID"},{"location":"Node/Classes/structstr_payload/#variable-msgid","text":"byte msgID;","title":"variable msgID"},{"location":"Node/Classes/structstr_payload/#variable-flag","text":"char flag;","title":"variable flag"},{"location":"Node/Classes/structstr_payload/#variable-sensorval","text":"byte sensorVal;","title":"variable sensorVal"},{"location":"Node/Classes/structstr_payload/#variable-rssi","text":"int RSSI;","title":"variable RSSI"},{"location":"Node/Classes/structstr_payload/#variable-snr","text":"float SNR; Updated on 2022-08-25 at 10:49:36 +0000","title":"variable SNR"},{"location":"Node/Examples/","text":"Examples Updated on 2022-08-25 at 10:49:36 +0000","title":"Examples"},{"location":"Node/Examples/#examples","text":"Updated on 2022-08-25 at 10:49:36 +0000","title":"Examples"},{"location":"Node/Files/","text":"Files dir /sensor_network/node/node_definitions file /sensor_network/node/node_definitions/node_definitions_1.h Definitions for node with id 1. file /sensor_network/node/node_definitions/node_definitions_2.h Definitions for node with id 2. file /sensor_network/node/node_definitions/node_definitions_3.h Definitions for node with id 3. file /sensor_network/node/node_definitions/node_definitions_4.h Definitions for node with id 4. file /sensor_network/node/node_definitions/node_definitions_uno.h Definitions for node with id 1. file comms_protocol.cpp Communication Protocol library - set of functions and data structures used to build a network using the LoRa modulation radios. file comms_protocol.h Header file for the communication protocol library. Contains the used data structures, function declaration and general configuartion options for the library. file node.ino Node script - send sensor data to gateway and receive commands from gateway. file node_definitions.h Header file for the node program. Contains hardware pinouts, LoRa modem configs and node settings. Updated on 2022-08-25 at 10:49:36 +0000","title":"Files"},{"location":"Node/Files/#files","text":"dir /sensor_network/node/node_definitions file /sensor_network/node/node_definitions/node_definitions_1.h Definitions for node with id 1. file /sensor_network/node/node_definitions/node_definitions_2.h Definitions for node with id 2. file /sensor_network/node/node_definitions/node_definitions_3.h Definitions for node with id 3. file /sensor_network/node/node_definitions/node_definitions_4.h Definitions for node with id 4. file /sensor_network/node/node_definitions/node_definitions_uno.h Definitions for node with id 1. file comms_protocol.cpp Communication Protocol library - set of functions and data structures used to build a network using the LoRa modulation radios. file comms_protocol.h Header file for the communication protocol library. Contains the used data structures, function declaration and general configuartion options for the library. file node.ino Node script - send sensor data to gateway and receive commands from gateway. file node_definitions.h Header file for the node program. Contains hardware pinouts, LoRa modem configs and node settings. Updated on 2022-08-25 at 10:49:36 +0000","title":"Files"},{"location":"Node/Files/comms__protocol_8cpp/","text":"comms_protocol.cpp Communication Protocol library - set of functions and data structures used to build a network using the LoRa modulation radios. More... Functions Name cppQueue msg_q (sizeof( Msg ) , MAX_QUEUE_SIZE , IMPLEMENTATION ) void LoRa_rxMode () Sets the LoRa radio to receive mode. void LoRa_txMode () Sets the LoRa radio to transmit mode. void LoRa_sendMessage (byte * message) Sets the radio to transmit mode, sends a message string using the LoRa radio and sets the radio back to receive mode. byte * splitAndEncrypt2 (char msg[MAX_PAYLOAD_SIZE]) Encrypts a message (character array) using the AES256 algorythm with the corresponding node key The encryption is made by encrypting blocks of 16 bytes and joining them together. char * decryptMsg2 (char msg[MAX_PAYLOAD_SIZE+1]) Decrypts a message string using the AES256 algorythm with the corresponding node key. int mymin (int a, int b) returns the minimum value between two integers void sendAck (byte msgID) Send an acknowledge message confirming the reception of an uplink transmission. void sendStatus (byte msgID) Send an uplink message containing the node status. void setActState (int ID, int val) Sets the state of the relevant actuator with the relevant value. void sendSensorData (byte sensorID, byte sensorVal) Adds to the message queue an uplink message containing sensor data. void getMsgFromQueueAndSend (unsigned long currentMillis) Get a message from the send queue and send it. Implements retransmission in case an acknowledge message is not received. Aware of a failed transmission. void onReceive (int packetSize) Called every time a new message is received. Filters unwanted messages, decrypts the payload, gets the relevant fields from the payload and sends back an acknowledge message if necessary. Attributes Name int currMsg int count unsigned long prevMil unsigned long prevMilSU float VBAT int msgCount aes256_context ctxt Detailed Description Communication Protocol library - set of functions and data structures used to build a network using the LoRa modulation radios. Author : Francisco Santos ( francisco.velez@tecnico.ulisboa.pt ) Version : 1.0 Date : 2022-08-10 Copyright : Copyright (c) 2022 Functions Documentation function msg_q cppQueue msg_q( sizeof(Msg) , MAX_QUEUE_SIZE , IMPLEMENTATION ) function LoRa_rxMode void LoRa_rxMode() Sets the LoRa radio to receive mode. Return : void function LoRa_txMode void LoRa_txMode() Sets the LoRa radio to transmit mode. Return : void function LoRa_sendMessage void LoRa_sendMessage( byte * message ) Sets the radio to transmit mode, sends a message string using the LoRa radio and sets the radio back to receive mode. Parameters : message message to send Return : void function splitAndEncrypt2 byte * splitAndEncrypt2( char msg[MAX_PAYLOAD_SIZE] ) Encrypts a message (character array) using the AES256 algorythm with the corresponding node key The encryption is made by encrypting blocks of 16 bytes and joining them together. Parameters : msg message array to be decrypted Return : byte* a byte array containing the encrypted message function decryptMsg2 char * decryptMsg2( char msg[MAX_PAYLOAD_SIZE+1] ) Decrypts a message string using the AES256 algorythm with the corresponding node key. Parameters : msg message string to be decrypted Return : char* an array of characters containing the decrypted message function mymin int mymin( int a, int b ) returns the minimum value between two integers Parameters : a first integer to compare b second integer to compare Return : int the smaller between a and b function sendAck void sendAck( byte msgID ) Send an acknowledge message confirming the reception of an uplink transmission. Parameters : msgID ID of the message being acknowledged Return : void function sendStatus void sendStatus( byte msgID ) Send an uplink message containing the node status. Parameters : msgID ID of the status request message Return : void function setActState void setActState( int ID, int val ) Sets the state of the relevant actuator with the relevant value. Parameters : ID ID of the relevant actuator val value to which the actuator is set to Return : void function sendSensorData void sendSensorData( byte sensorID, byte sensorVal ) Adds to the message queue an uplink message containing sensor data. Parameters : sensorID ID of the relevant sensor sensorVal value read from the relevant sensor Return : void Note: The ADC value is a 12-bit number, so the maximum value is 4095 (counting from 0). To convert the ADC integer value to a real voltage you\u2019ll need to divide it by the maximum value of 4095, then double it (note above that Adafruit halves the voltage), then multiply that by the reference voltage of the ESP32 which is 3.3V and then vinally, multiply that again by the ADC Reference Voltage of 1100mV. function getMsgFromQueueAndSend void getMsgFromQueueAndSend( unsigned long currentMillis ) Get a message from the send queue and send it. Implements retransmission in case an acknowledge message is not received. Aware of a failed transmission. Parameters : currentMillis current time in millisenconds since boot Return : void function onReceive void onReceive( int packetSize ) Called every time a new message is received. Filters unwanted messages, decrypts the payload, gets the relevant fields from the payload and sends back an acknowledge message if necessary. Parameters : packetSize size of the incoming message in bytes Return : void Attributes Documentation variable currMsg int currMsg = -1; variable count int count = 0; variable prevMil unsigned long prevMil; variable prevMilSU unsigned long prevMilSU; variable VBAT float VBAT = 1.0; variable msgCount int msgCount = 0; variable ctxt aes256_context ctxt; Source code #include \"comms_protocol.h\" int currMsg = -1; int count = 0; unsigned long prevMil; unsigned long prevMilSU; float VBAT = 1.0; int msgCount = 0; cppQueue msg_q(sizeof(Msg), MAX_QUEUE_SIZE, IMPLEMENTATION); aes256_context ctxt; void LoRa_rxMode() { LoRa.enableInvertIQ(); LoRa.receive(); } void LoRa_txMode() { LoRa.idle(); LoRa.disableInvertIQ(); } void LoRa_sendMessage(byte *message) { LoRa_txMode(); // set tx mode LoRa.beginPacket(); // start packet LoRa.write(netID); LoRa.write(nodeID); //LoRa.print(message); // add payload LoRa.write(message, MAX_ENC_PAYLOAD_SIZE); LoRa.endPacket(false); // finish packet and send it LoRa_rxMode(); } /*String splitAndEncrypt(char msg[MAX_PAYLOAD_SIZE]) { String enc = \"\"; aes256_init(&ctxt,(uint8_t *) key); const char * p = msg; while (strlen (p) > 0) { byte plain [BLOCK_SIZE]; memset (plain, 0, BLOCK_SIZE); // ensure trailing zeros memcpy (plain, p, mymin (strlen (p), BLOCK_SIZE)); aes256_encrypt_ecb(&ctxt, plain); enc += String((char *)plain); p += mymin (strlen (p), BLOCK_SIZE); } aes256_done(&ctxt); return enc; }*/ byte *splitAndEncrypt2(char msg[MAX_PAYLOAD_SIZE]) { String enc = \"\"; aes256_init(&ctxt,(uint8_t *) key); const char * p = msg; static byte plain [BLOCK_SIZE]; while (strlen (p) > 0) { memset (plain, 0, BLOCK_SIZE); // ensure trailing zeros memcpy (plain, p, mymin (strlen (p), BLOCK_SIZE)); aes256_encrypt_ecb(&ctxt, plain); return plain; enc += String((char *)plain); p += mymin (strlen (p), BLOCK_SIZE); } aes256_done(&ctxt); } /* * Function: decryptMsg * ---------------------------- * Decrypts a message string using the AES256 algorythm with the corresponding node key * * msg: message string to be decrypted * * returns: an array of characters containing the decrypted message char *decryptMsg(String msg) { static uint8_t data[MAX_PAYLOAD_SIZE+1]; static char m[MAX_PAYLOAD_SIZE+1]; msg.toCharArray(m, MAX_PAYLOAD_SIZE+1); aes256_decrypt_ecb(&ctxt, (uint8_t *)m); return (char *)m; }*/ char *decryptMsg2(char msg[MAX_PAYLOAD_SIZE+1]) { static uint8_t data[MAX_PAYLOAD_SIZE+1]; memcpy(data, msg, MAX_PAYLOAD_SIZE+1); //static char m[MAX_PAYLOAD_SIZE+1]; //msg.toCharArray(m, MAX_PAYLOAD_SIZE+1); aes256_decrypt_ecb(&ctxt, (uint8_t *)data); return (char *)data; } int mymin(int a, int b){ if (a>b) return b; return a; } void sendAck(byte msgID) { String enc; char payload[MAX_PAYLOAD_SIZE]; char encP[MAX_ENC_PAYLOAD_SIZE]; byte l = (byte)MAX_PAYLOAD_SIZE; Msg msg; #if defined(ESP32) VBAT = (float)(analogRead(vbatPin)) / 4095*2*3.3*1.1; #endif int a = VBAT; int b = VBAT*10-a*10; sprintf(payload, \"%c%c%c%c%c%c%c%c\", (char)nodeID, (char)msgID, (char)l, 'a', (char)48, (char)48, (char)a+1, (char)b+1); //enc = splitAndEncrypt(payload); //enc.toCharArray(msg.msg, MAX_ENC_PAYLOAD_SIZE); byte *plain = splitAndEncrypt2(payload); memcpy(msg.msg, plain, MAX_PAYLOAD_SIZE); msg.msg[MAX_PAYLOAD_SIZE] = '\\0'; Serial.print(\"add ack to queue: \"); Serial.println(payload); //Serial.print(\"enc msg: \"); //Serial.println(msg.msg); msg.msgID = msgID; msg.flag = 'a'; msg_q.push(&msg); } void sendStatus(byte msgID) { Msg msg; String enc; char payload[MAX_PAYLOAD_SIZE]; msg.msgID = msgID; byte l = (byte) MAX_PAYLOAD_SIZE; #if defined(ESP32) VBAT = (float)(analogRead(vbatPin)) / 4095*2*3.3*1.1; #endif int a = VBAT; int b = VBAT*10-a*10; sprintf(payload, \"%c%c%c%c%c%c%c%c\", (char)nodeID, (char)msgID, (char)l, 's', (char)48, (char)48, (char)a+1, (char)b+1); //enc = splitAndEncrypt(payload); //enc.toCharArray(msg.msg, MAX_ENC_PAYLOAD_SIZE); byte *plain = splitAndEncrypt2(payload); memcpy(msg.msg, plain, MAX_PAYLOAD_SIZE); msg.msg[MAX_PAYLOAD_SIZE] = '\\0'; Serial.print(\"add status to queue: \"); Serial.println(payload); //Serial.print(\"enc msg: \"); //Serial.println(msg.msg); // Add msg to msg queue msg.flag = 's'; msg_q.push(&msg); } void setActState(int ID, int val) { Serial.print(\"Set actuator: \"); Serial.print(ID); Serial.print(\" with value: \"); Serial.println(val); digitalWrite(actPin[ID], val); } void sendSensorData(byte sensorID, byte sensorVal) { Msg msg; String enc; char payload[MAX_PAYLOAD_SIZE]; msgCount ++; if (msgCount == 0) msgCount ++; msg.msgID = (byte) msgCount; byte l = MAX_PAYLOAD_SIZE; #if defined(ESP32) VBAT = (float)(analogRead(vbatPin)) / 4095*2*3.3*1.1; #endif Serial.println(VBAT); int a = VBAT; int b = VBAT*10-a*10; sprintf(payload, \"%c%c%c%c%c%c%c%c\", (char)nodeID, (char)msg.msgID, (char)l, 'u', (char)(sensorID + 1), (char)(sensorVal + 1), (char)a+1, (char)b+1); //enc = splitAndEncrypt(payload); //enc.toCharArray(msg.msg, MAX_ENC_PAYLOAD_SIZE); byte *plain = splitAndEncrypt2(payload); memcpy(msg.msg, plain, MAX_PAYLOAD_SIZE); msg.msg[MAX_PAYLOAD_SIZE] = '\\0'; // Add msg to msg queue msg.flag = 'u'; msg_q.push(&msg); } void getMsgFromQueueAndSend(unsigned long currentMillis) { if (!msg_q.isEmpty()) { Msg msg; msg_q.peek(&msg); if (currMsg == msg.msgID) count ++; else count = 0; currMsg = msg.msgID; if (count < MAX_N_RETRY) { Serial.print(\"send msg: \"); //Serial.println(msg.msg); LoRa_sendMessage(msg.msg); if ((msg.flag == 's') || (msg.flag == 'a')){ msg_q.drop(); currMsg = -1; } } else { Serial.print(\"Failed to send msg with id: \"); Serial.println(msg.msgID); msg_q.drop(); currMsg = -1; } prevMil = currentMillis; } } void onReceive(int packetSize){ byte rNetID = LoRa.read(); byte rnID = LoRa.read(); char buffer1[MAX_ENC_PAYLOAD_SIZE]; char buffer2[MAX_ENC_PAYLOAD_SIZE]; String message = \"\"; int i=0; while (LoRa.available() && i<MAX_ENC_PAYLOAD_SIZE) { //Serial.println(LoRa.peek(), HEX); buffer1[i] = (char)LoRa.read(); //message += (char)LoRa.read(); i++; } Serial.println(\"msg\"); //Serial.println(message.length()); //Serial.println(MAX_ENC_PAYLOAD_SIZE); //Serial.println(rNetID == netID); if (rNetID == netID) { Serial.println(\"New msg received\"); //int j = message.length() / ENC_BLOCK_SIZE; //int h = message.length() / (1 * j); byte len; Payload p; if (rnID == BROADCAST_ID) aes256_init(&ctxt,(uint8_t *) keyBroadcast); else aes256_init(&ctxt,(uint8_t *) key); //for (int i = 0; i < j; i++) { // if (i == 0) // strcpy(buffer1, decryptMsg(message.substring(i * ENC_BLOCK_SIZE, (i + 1) * ENC_BLOCK_SIZE))); // else // strcat(buffer1, decryptMsg(message.substring(i * ENC_BLOCK_SIZE, (i + 1) * ENC_BLOCK_SIZE))); //} strcpy(buffer2, decryptMsg2(buffer1)); aes256_done(&ctxt); buffer2[6] = '\\0'; Serial.println(buffer2); if(sscanf(buffer2, \"%c%c%c%c%c%c\", &p.nodeID, &p.msgID, &len, &p.flag, &p.sensorID, &p.sensorVal) == 6){ Serial.println(p.flag); Msg msg; msg_q.peek(&msg); if (p.nodeID == nodeID || p.nodeID == BROADCAST_ID) { if (p.flag == 'a') { if (p.msgID == msg.msgID) { Serial.print(\"Message with ID: \"); Serial.print(p.msgID); Serial.println(\" delivered!\"); msg_q.drop(); } } else if (p.flag == 's') { Serial.print(\"received msg with id: \"); Serial.println(p.msgID); sendStatus(p.msgID); } else if (p.flag == 'c') { // Set actuator value and send ack setActState((int)(p.sensorID - 1), (int)(p.sensorVal - 1)); sendAck(p.msgID); } } } } } Updated on 2022-08-25 at 10:49:36 +0000","title":"comms_protocol.cpp"},{"location":"Node/Files/comms__protocol_8cpp/#comms_protocolcpp","text":"Communication Protocol library - set of functions and data structures used to build a network using the LoRa modulation radios. More...","title":"comms_protocol.cpp"},{"location":"Node/Files/comms__protocol_8cpp/#functions","text":"Name cppQueue msg_q (sizeof( Msg ) , MAX_QUEUE_SIZE , IMPLEMENTATION ) void LoRa_rxMode () Sets the LoRa radio to receive mode. void LoRa_txMode () Sets the LoRa radio to transmit mode. void LoRa_sendMessage (byte * message) Sets the radio to transmit mode, sends a message string using the LoRa radio and sets the radio back to receive mode. byte * splitAndEncrypt2 (char msg[MAX_PAYLOAD_SIZE]) Encrypts a message (character array) using the AES256 algorythm with the corresponding node key The encryption is made by encrypting blocks of 16 bytes and joining them together. char * decryptMsg2 (char msg[MAX_PAYLOAD_SIZE+1]) Decrypts a message string using the AES256 algorythm with the corresponding node key. int mymin (int a, int b) returns the minimum value between two integers void sendAck (byte msgID) Send an acknowledge message confirming the reception of an uplink transmission. void sendStatus (byte msgID) Send an uplink message containing the node status. void setActState (int ID, int val) Sets the state of the relevant actuator with the relevant value. void sendSensorData (byte sensorID, byte sensorVal) Adds to the message queue an uplink message containing sensor data. void getMsgFromQueueAndSend (unsigned long currentMillis) Get a message from the send queue and send it. Implements retransmission in case an acknowledge message is not received. Aware of a failed transmission. void onReceive (int packetSize) Called every time a new message is received. Filters unwanted messages, decrypts the payload, gets the relevant fields from the payload and sends back an acknowledge message if necessary.","title":"Functions"},{"location":"Node/Files/comms__protocol_8cpp/#attributes","text":"Name int currMsg int count unsigned long prevMil unsigned long prevMilSU float VBAT int msgCount aes256_context ctxt","title":"Attributes"},{"location":"Node/Files/comms__protocol_8cpp/#detailed-description","text":"Communication Protocol library - set of functions and data structures used to build a network using the LoRa modulation radios. Author : Francisco Santos ( francisco.velez@tecnico.ulisboa.pt ) Version : 1.0 Date : 2022-08-10 Copyright : Copyright (c) 2022","title":"Detailed Description"},{"location":"Node/Files/comms__protocol_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Node/Files/comms__protocol_8cpp/#function-msg_q","text":"cppQueue msg_q( sizeof(Msg) , MAX_QUEUE_SIZE , IMPLEMENTATION )","title":"function msg_q"},{"location":"Node/Files/comms__protocol_8cpp/#function-lora_rxmode","text":"void LoRa_rxMode() Sets the LoRa radio to receive mode. Return : void","title":"function LoRa_rxMode"},{"location":"Node/Files/comms__protocol_8cpp/#function-lora_txmode","text":"void LoRa_txMode() Sets the LoRa radio to transmit mode. Return : void","title":"function LoRa_txMode"},{"location":"Node/Files/comms__protocol_8cpp/#function-lora_sendmessage","text":"void LoRa_sendMessage( byte * message ) Sets the radio to transmit mode, sends a message string using the LoRa radio and sets the radio back to receive mode. Parameters : message message to send Return : void","title":"function LoRa_sendMessage"},{"location":"Node/Files/comms__protocol_8cpp/#function-splitandencrypt2","text":"byte * splitAndEncrypt2( char msg[MAX_PAYLOAD_SIZE] ) Encrypts a message (character array) using the AES256 algorythm with the corresponding node key The encryption is made by encrypting blocks of 16 bytes and joining them together. Parameters : msg message array to be decrypted Return : byte* a byte array containing the encrypted message","title":"function splitAndEncrypt2"},{"location":"Node/Files/comms__protocol_8cpp/#function-decryptmsg2","text":"char * decryptMsg2( char msg[MAX_PAYLOAD_SIZE+1] ) Decrypts a message string using the AES256 algorythm with the corresponding node key. Parameters : msg message string to be decrypted Return : char* an array of characters containing the decrypted message","title":"function decryptMsg2"},{"location":"Node/Files/comms__protocol_8cpp/#function-mymin","text":"int mymin( int a, int b ) returns the minimum value between two integers Parameters : a first integer to compare b second integer to compare Return : int the smaller between a and b","title":"function mymin"},{"location":"Node/Files/comms__protocol_8cpp/#function-sendack","text":"void sendAck( byte msgID ) Send an acknowledge message confirming the reception of an uplink transmission. Parameters : msgID ID of the message being acknowledged Return : void","title":"function sendAck"},{"location":"Node/Files/comms__protocol_8cpp/#function-sendstatus","text":"void sendStatus( byte msgID ) Send an uplink message containing the node status. Parameters : msgID ID of the status request message Return : void","title":"function sendStatus"},{"location":"Node/Files/comms__protocol_8cpp/#function-setactstate","text":"void setActState( int ID, int val ) Sets the state of the relevant actuator with the relevant value. Parameters : ID ID of the relevant actuator val value to which the actuator is set to Return : void","title":"function setActState"},{"location":"Node/Files/comms__protocol_8cpp/#function-sendsensordata","text":"void sendSensorData( byte sensorID, byte sensorVal ) Adds to the message queue an uplink message containing sensor data. Parameters : sensorID ID of the relevant sensor sensorVal value read from the relevant sensor Return : void Note: The ADC value is a 12-bit number, so the maximum value is 4095 (counting from 0). To convert the ADC integer value to a real voltage you\u2019ll need to divide it by the maximum value of 4095, then double it (note above that Adafruit halves the voltage), then multiply that by the reference voltage of the ESP32 which is 3.3V and then vinally, multiply that again by the ADC Reference Voltage of 1100mV.","title":"function sendSensorData"},{"location":"Node/Files/comms__protocol_8cpp/#function-getmsgfromqueueandsend","text":"void getMsgFromQueueAndSend( unsigned long currentMillis ) Get a message from the send queue and send it. Implements retransmission in case an acknowledge message is not received. Aware of a failed transmission. Parameters : currentMillis current time in millisenconds since boot Return : void","title":"function getMsgFromQueueAndSend"},{"location":"Node/Files/comms__protocol_8cpp/#function-onreceive","text":"void onReceive( int packetSize ) Called every time a new message is received. Filters unwanted messages, decrypts the payload, gets the relevant fields from the payload and sends back an acknowledge message if necessary. Parameters : packetSize size of the incoming message in bytes Return : void","title":"function onReceive"},{"location":"Node/Files/comms__protocol_8cpp/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Node/Files/comms__protocol_8cpp/#variable-currmsg","text":"int currMsg = -1;","title":"variable currMsg"},{"location":"Node/Files/comms__protocol_8cpp/#variable-count","text":"int count = 0;","title":"variable count"},{"location":"Node/Files/comms__protocol_8cpp/#variable-prevmil","text":"unsigned long prevMil;","title":"variable prevMil"},{"location":"Node/Files/comms__protocol_8cpp/#variable-prevmilsu","text":"unsigned long prevMilSU;","title":"variable prevMilSU"},{"location":"Node/Files/comms__protocol_8cpp/#variable-vbat","text":"float VBAT = 1.0;","title":"variable VBAT"},{"location":"Node/Files/comms__protocol_8cpp/#variable-msgcount","text":"int msgCount = 0;","title":"variable msgCount"},{"location":"Node/Files/comms__protocol_8cpp/#variable-ctxt","text":"aes256_context ctxt;","title":"variable ctxt"},{"location":"Node/Files/comms__protocol_8cpp/#source-code","text":"#include \"comms_protocol.h\" int currMsg = -1; int count = 0; unsigned long prevMil; unsigned long prevMilSU; float VBAT = 1.0; int msgCount = 0; cppQueue msg_q(sizeof(Msg), MAX_QUEUE_SIZE, IMPLEMENTATION); aes256_context ctxt; void LoRa_rxMode() { LoRa.enableInvertIQ(); LoRa.receive(); } void LoRa_txMode() { LoRa.idle(); LoRa.disableInvertIQ(); } void LoRa_sendMessage(byte *message) { LoRa_txMode(); // set tx mode LoRa.beginPacket(); // start packet LoRa.write(netID); LoRa.write(nodeID); //LoRa.print(message); // add payload LoRa.write(message, MAX_ENC_PAYLOAD_SIZE); LoRa.endPacket(false); // finish packet and send it LoRa_rxMode(); } /*String splitAndEncrypt(char msg[MAX_PAYLOAD_SIZE]) { String enc = \"\"; aes256_init(&ctxt,(uint8_t *) key); const char * p = msg; while (strlen (p) > 0) { byte plain [BLOCK_SIZE]; memset (plain, 0, BLOCK_SIZE); // ensure trailing zeros memcpy (plain, p, mymin (strlen (p), BLOCK_SIZE)); aes256_encrypt_ecb(&ctxt, plain); enc += String((char *)plain); p += mymin (strlen (p), BLOCK_SIZE); } aes256_done(&ctxt); return enc; }*/ byte *splitAndEncrypt2(char msg[MAX_PAYLOAD_SIZE]) { String enc = \"\"; aes256_init(&ctxt,(uint8_t *) key); const char * p = msg; static byte plain [BLOCK_SIZE]; while (strlen (p) > 0) { memset (plain, 0, BLOCK_SIZE); // ensure trailing zeros memcpy (plain, p, mymin (strlen (p), BLOCK_SIZE)); aes256_encrypt_ecb(&ctxt, plain); return plain; enc += String((char *)plain); p += mymin (strlen (p), BLOCK_SIZE); } aes256_done(&ctxt); } /* * Function: decryptMsg * ---------------------------- * Decrypts a message string using the AES256 algorythm with the corresponding node key * * msg: message string to be decrypted * * returns: an array of characters containing the decrypted message char *decryptMsg(String msg) { static uint8_t data[MAX_PAYLOAD_SIZE+1]; static char m[MAX_PAYLOAD_SIZE+1]; msg.toCharArray(m, MAX_PAYLOAD_SIZE+1); aes256_decrypt_ecb(&ctxt, (uint8_t *)m); return (char *)m; }*/ char *decryptMsg2(char msg[MAX_PAYLOAD_SIZE+1]) { static uint8_t data[MAX_PAYLOAD_SIZE+1]; memcpy(data, msg, MAX_PAYLOAD_SIZE+1); //static char m[MAX_PAYLOAD_SIZE+1]; //msg.toCharArray(m, MAX_PAYLOAD_SIZE+1); aes256_decrypt_ecb(&ctxt, (uint8_t *)data); return (char *)data; } int mymin(int a, int b){ if (a>b) return b; return a; } void sendAck(byte msgID) { String enc; char payload[MAX_PAYLOAD_SIZE]; char encP[MAX_ENC_PAYLOAD_SIZE]; byte l = (byte)MAX_PAYLOAD_SIZE; Msg msg; #if defined(ESP32) VBAT = (float)(analogRead(vbatPin)) / 4095*2*3.3*1.1; #endif int a = VBAT; int b = VBAT*10-a*10; sprintf(payload, \"%c%c%c%c%c%c%c%c\", (char)nodeID, (char)msgID, (char)l, 'a', (char)48, (char)48, (char)a+1, (char)b+1); //enc = splitAndEncrypt(payload); //enc.toCharArray(msg.msg, MAX_ENC_PAYLOAD_SIZE); byte *plain = splitAndEncrypt2(payload); memcpy(msg.msg, plain, MAX_PAYLOAD_SIZE); msg.msg[MAX_PAYLOAD_SIZE] = '\\0'; Serial.print(\"add ack to queue: \"); Serial.println(payload); //Serial.print(\"enc msg: \"); //Serial.println(msg.msg); msg.msgID = msgID; msg.flag = 'a'; msg_q.push(&msg); } void sendStatus(byte msgID) { Msg msg; String enc; char payload[MAX_PAYLOAD_SIZE]; msg.msgID = msgID; byte l = (byte) MAX_PAYLOAD_SIZE; #if defined(ESP32) VBAT = (float)(analogRead(vbatPin)) / 4095*2*3.3*1.1; #endif int a = VBAT; int b = VBAT*10-a*10; sprintf(payload, \"%c%c%c%c%c%c%c%c\", (char)nodeID, (char)msgID, (char)l, 's', (char)48, (char)48, (char)a+1, (char)b+1); //enc = splitAndEncrypt(payload); //enc.toCharArray(msg.msg, MAX_ENC_PAYLOAD_SIZE); byte *plain = splitAndEncrypt2(payload); memcpy(msg.msg, plain, MAX_PAYLOAD_SIZE); msg.msg[MAX_PAYLOAD_SIZE] = '\\0'; Serial.print(\"add status to queue: \"); Serial.println(payload); //Serial.print(\"enc msg: \"); //Serial.println(msg.msg); // Add msg to msg queue msg.flag = 's'; msg_q.push(&msg); } void setActState(int ID, int val) { Serial.print(\"Set actuator: \"); Serial.print(ID); Serial.print(\" with value: \"); Serial.println(val); digitalWrite(actPin[ID], val); } void sendSensorData(byte sensorID, byte sensorVal) { Msg msg; String enc; char payload[MAX_PAYLOAD_SIZE]; msgCount ++; if (msgCount == 0) msgCount ++; msg.msgID = (byte) msgCount; byte l = MAX_PAYLOAD_SIZE; #if defined(ESP32) VBAT = (float)(analogRead(vbatPin)) / 4095*2*3.3*1.1; #endif Serial.println(VBAT); int a = VBAT; int b = VBAT*10-a*10; sprintf(payload, \"%c%c%c%c%c%c%c%c\", (char)nodeID, (char)msg.msgID, (char)l, 'u', (char)(sensorID + 1), (char)(sensorVal + 1), (char)a+1, (char)b+1); //enc = splitAndEncrypt(payload); //enc.toCharArray(msg.msg, MAX_ENC_PAYLOAD_SIZE); byte *plain = splitAndEncrypt2(payload); memcpy(msg.msg, plain, MAX_PAYLOAD_SIZE); msg.msg[MAX_PAYLOAD_SIZE] = '\\0'; // Add msg to msg queue msg.flag = 'u'; msg_q.push(&msg); } void getMsgFromQueueAndSend(unsigned long currentMillis) { if (!msg_q.isEmpty()) { Msg msg; msg_q.peek(&msg); if (currMsg == msg.msgID) count ++; else count = 0; currMsg = msg.msgID; if (count < MAX_N_RETRY) { Serial.print(\"send msg: \"); //Serial.println(msg.msg); LoRa_sendMessage(msg.msg); if ((msg.flag == 's') || (msg.flag == 'a')){ msg_q.drop(); currMsg = -1; } } else { Serial.print(\"Failed to send msg with id: \"); Serial.println(msg.msgID); msg_q.drop(); currMsg = -1; } prevMil = currentMillis; } } void onReceive(int packetSize){ byte rNetID = LoRa.read(); byte rnID = LoRa.read(); char buffer1[MAX_ENC_PAYLOAD_SIZE]; char buffer2[MAX_ENC_PAYLOAD_SIZE]; String message = \"\"; int i=0; while (LoRa.available() && i<MAX_ENC_PAYLOAD_SIZE) { //Serial.println(LoRa.peek(), HEX); buffer1[i] = (char)LoRa.read(); //message += (char)LoRa.read(); i++; } Serial.println(\"msg\"); //Serial.println(message.length()); //Serial.println(MAX_ENC_PAYLOAD_SIZE); //Serial.println(rNetID == netID); if (rNetID == netID) { Serial.println(\"New msg received\"); //int j = message.length() / ENC_BLOCK_SIZE; //int h = message.length() / (1 * j); byte len; Payload p; if (rnID == BROADCAST_ID) aes256_init(&ctxt,(uint8_t *) keyBroadcast); else aes256_init(&ctxt,(uint8_t *) key); //for (int i = 0; i < j; i++) { // if (i == 0) // strcpy(buffer1, decryptMsg(message.substring(i * ENC_BLOCK_SIZE, (i + 1) * ENC_BLOCK_SIZE))); // else // strcat(buffer1, decryptMsg(message.substring(i * ENC_BLOCK_SIZE, (i + 1) * ENC_BLOCK_SIZE))); //} strcpy(buffer2, decryptMsg2(buffer1)); aes256_done(&ctxt); buffer2[6] = '\\0'; Serial.println(buffer2); if(sscanf(buffer2, \"%c%c%c%c%c%c\", &p.nodeID, &p.msgID, &len, &p.flag, &p.sensorID, &p.sensorVal) == 6){ Serial.println(p.flag); Msg msg; msg_q.peek(&msg); if (p.nodeID == nodeID || p.nodeID == BROADCAST_ID) { if (p.flag == 'a') { if (p.msgID == msg.msgID) { Serial.print(\"Message with ID: \"); Serial.print(p.msgID); Serial.println(\" delivered!\"); msg_q.drop(); } } else if (p.flag == 's') { Serial.print(\"received msg with id: \"); Serial.println(p.msgID); sendStatus(p.msgID); } else if (p.flag == 'c') { // Set actuator value and send ack setActState((int)(p.sensorID - 1), (int)(p.sensorVal - 1)); sendAck(p.msgID); } } } } } Updated on 2022-08-25 at 10:49:36 +0000","title":"Source code"},{"location":"Node/Files/comms__protocol_8h/","text":"comms_protocol.h Header file for the communication protocol library. Contains the used data structures, function declaration and general configuartion options for the library. More... Classes Name struct strPayload struct strMsg Types Name typedef struct strPayload Payload typedef struct strMsg Msg Functions Name void LoRa_rxMode () Sets the LoRa radio to receive mode. void LoRa_txMode () Sets the LoRa radio to transmit mode. void LoRa_sendMessage (byte * message) Sets the radio to transmit mode, sends a message string using the LoRa radio and sets the radio back to receive mode. char * decryptMsg (String msg) char * decryptMsg2 (char msg[MAX_PAYLOAD_SIZE+1]) Decrypts a message string using the AES256 algorythm with the corresponding node key. void onReceive (int packetSize) Called every time a new message is received. Filters unwanted messages, decrypts the payload, gets the relevant fields from the payload and sends back an acknowledge message if necessary. void onTxDone () String splitAndEncrypt (char msg[MAX_PAYLOAD_SIZE]) void sendSensorData (byte sensorID, byte sensorVal) Adds to the message queue an uplink message containing sensor data. void getMsgFromQueueAndSend (unsigned long currentMillis) Get a message from the send queue and send it. Implements retransmission in case an acknowledge message is not received. Aware of a failed transmission. void sendStatus (byte msgID) Send an uplink message containing the node status. void sendAck (byte msgID) Send an acknowledge message confirming the reception of an uplink transmission. void setActState (int ID, int val) Sets the state of the relevant actuator with the relevant value. int mymin (int a, int b) returns the minimum value between two integers Attributes Name const uint8_t keyBroadcast const long frequency const int txPower const int spreadingFactor const long signalBandwidth const int codingRateDenominator int currMsg int count unsigned long prevMil unsigned long prevMilSU int msgCount cppQueue msg_q aes256_context ctxt Defines Name IMPLEMENTATION MAX_N_RETRY TIMEOUT_INTERVAL MAX_QUEUE_SIZE BLOCK_SIZE MAX_PAYLOAD_SIZE ENC_BLOCK_SIZE MAX_ENC_PAYLOAD_SIZE MAX_MSG_ID STATUS_UPDATE_INTERVAL BROADCAST_ID Detailed Description Header file for the communication protocol library. Contains the used data structures, function declaration and general configuartion options for the library. Author : Francisco Santos ( francisco.velez@tecnico.ulisboa.pt ) Version : 1.0 Date : 2022-08-10 Copyright : Copyright (c) 2022 Types Documentation typedef Payload typedef struct strPayload Payload; typedef Msg typedef struct strMsg Msg; Functions Documentation function LoRa_rxMode void LoRa_rxMode() Sets the LoRa radio to receive mode. Return : void function LoRa_txMode void LoRa_txMode() Sets the LoRa radio to transmit mode. Return : void function LoRa_sendMessage void LoRa_sendMessage( byte * message ) Sets the radio to transmit mode, sends a message string using the LoRa radio and sets the radio back to receive mode. Parameters : message message to send Return : void function decryptMsg char * decryptMsg( String msg ) function decryptMsg2 char * decryptMsg2( char msg[MAX_PAYLOAD_SIZE+1] ) Decrypts a message string using the AES256 algorythm with the corresponding node key. Parameters : msg message string to be decrypted Return : char* an array of characters containing the decrypted message function onReceive void onReceive( int packetSize ) Called every time a new message is received. Filters unwanted messages, decrypts the payload, gets the relevant fields from the payload and sends back an acknowledge message if necessary. Parameters : packetSize size of the incoming message in bytes Return : void function onTxDone void onTxDone() function splitAndEncrypt String splitAndEncrypt( char msg[MAX_PAYLOAD_SIZE] ) function sendSensorData void sendSensorData( byte sensorID, byte sensorVal ) Adds to the message queue an uplink message containing sensor data. Parameters : sensorID ID of the relevant sensor sensorVal value read from the relevant sensor Return : void Note: The ADC value is a 12-bit number, so the maximum value is 4095 (counting from 0). To convert the ADC integer value to a real voltage you\u2019ll need to divide it by the maximum value of 4095, then double it (note above that Adafruit halves the voltage), then multiply that by the reference voltage of the ESP32 which is 3.3V and then vinally, multiply that again by the ADC Reference Voltage of 1100mV. function getMsgFromQueueAndSend void getMsgFromQueueAndSend( unsigned long currentMillis ) Get a message from the send queue and send it. Implements retransmission in case an acknowledge message is not received. Aware of a failed transmission. Parameters : currentMillis current time in millisenconds since boot Return : void function sendStatus void sendStatus( byte msgID ) Send an uplink message containing the node status. Parameters : msgID ID of the status request message Return : void function sendAck void sendAck( byte msgID ) Send an acknowledge message confirming the reception of an uplink transmission. Parameters : msgID ID of the message being acknowledged Return : void function setActState void setActState( int ID, int val ) Sets the state of the relevant actuator with the relevant value. Parameters : ID ID of the relevant actuator val value to which the actuator is set to Return : void function mymin int mymin( int a, int b ) returns the minimum value between two integers Parameters : a first integer to compare b second integer to compare Return : int the smaller between a and b Attributes Documentation variable keyBroadcast const uint8_t keyBroadcast = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x0f }; variable frequency const long frequency = 868E6; variable txPower const int txPower = 14; variable spreadingFactor const int spreadingFactor = 7; variable signalBandwidth const long signalBandwidth = 125E3; variable codingRateDenominator const int codingRateDenominator = 5; variable currMsg int currMsg; variable count int count; variable prevMil unsigned long prevMil; variable prevMilSU unsigned long prevMilSU; variable msgCount int msgCount; variable msg_q cppQueue msg_q; variable ctxt aes256_context ctxt; Macros Documentation define IMPLEMENTATION #define IMPLEMENTATION FIFO define MAX_N_RETRY #define MAX_N_RETRY 3 define TIMEOUT_INTERVAL #define TIMEOUT_INTERVAL 1000 define MAX_QUEUE_SIZE #define MAX_QUEUE_SIZE 5 define BLOCK_SIZE #define BLOCK_SIZE 16 define MAX_PAYLOAD_SIZE #define MAX_PAYLOAD_SIZE 16 define ENC_BLOCK_SIZE #define ENC_BLOCK_SIZE (1*BLOCK_SIZE) define MAX_ENC_PAYLOAD_SIZE #define MAX_ENC_PAYLOAD_SIZE ((MAX_PAYLOAD_SIZE/BLOCK_SIZE)*ENC_BLOCK_SIZE)+1 define MAX_MSG_ID #define MAX_MSG_ID 256 define STATUS_UPDATE_INTERVAL #define STATUS_UPDATE_INTERVAL 60000 define BROADCAST_ID #define BROADCAST_ID 0xFF Source code #ifndef COMMS_PROTOCOL_H #define COMMS_PROTOCOL_H #include <Arduino.h> #include <SPI.h> #include <LoRa.h> #include <cppQueue.h> #include <aes256.h> #include \"node_definitions.h\" #define IMPLEMENTATION FIFO // LoRa msg payload settings #define MAX_N_RETRY 3 #define TIMEOUT_INTERVAL 1000 #define MAX_QUEUE_SIZE 5 #define BLOCK_SIZE 16 #define MAX_PAYLOAD_SIZE 16 #define ENC_BLOCK_SIZE (1*BLOCK_SIZE) #define MAX_ENC_PAYLOAD_SIZE ((MAX_PAYLOAD_SIZE/BLOCK_SIZE)*ENC_BLOCK_SIZE)+1 #define MAX_MSG_ID 256 #define STATUS_UPDATE_INTERVAL 60000 #define BROADCAST_ID 0xFF // Broadcast Encryption key const uint8_t keyBroadcast[] = { // 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x0f }; // LoRa Modem Settings const long frequency = 868E6; const int txPower = 14; const int spreadingFactor = 7; const long signalBandwidth = 125E3; const int codingRateDenominator = 5; typedef struct strPayload { byte nodeID; byte sensorID; byte msgID; char flag; byte sensorVal; int RSSI; float SNR; } Payload; typedef struct strMsg { byte msg[MAX_ENC_PAYLOAD_SIZE]; byte msgID; char flag; } Msg; extern int currMsg; extern int count; extern unsigned long prevMil; extern unsigned long prevMilSU; extern int msgCount; extern cppQueue msg_q; extern aes256_context ctxt; void LoRa_rxMode(); void LoRa_txMode(); void LoRa_sendMessage(byte *message); char *decryptMsg(String msg); char *decryptMsg2(char msg[MAX_PAYLOAD_SIZE+1]); void onReceive(int packetSize); void onTxDone(); String splitAndEncrypt(char msg[MAX_PAYLOAD_SIZE]); void sendSensorData(byte sensorID, byte sensorVal); void getMsgFromQueueAndSend(unsigned long currentMillis); void sendStatus(byte msgID); void sendAck(byte msgID); void setActState(int ID, int val); int mymin(int a, int b); #endif Updated on 2022-08-25 at 10:49:36 +0000","title":"comms_protocol.h"},{"location":"Node/Files/comms__protocol_8h/#comms_protocolh","text":"Header file for the communication protocol library. Contains the used data structures, function declaration and general configuartion options for the library. More...","title":"comms_protocol.h"},{"location":"Node/Files/comms__protocol_8h/#classes","text":"Name struct strPayload struct strMsg","title":"Classes"},{"location":"Node/Files/comms__protocol_8h/#types","text":"Name typedef struct strPayload Payload typedef struct strMsg Msg","title":"Types"},{"location":"Node/Files/comms__protocol_8h/#functions","text":"Name void LoRa_rxMode () Sets the LoRa radio to receive mode. void LoRa_txMode () Sets the LoRa radio to transmit mode. void LoRa_sendMessage (byte * message) Sets the radio to transmit mode, sends a message string using the LoRa radio and sets the radio back to receive mode. char * decryptMsg (String msg) char * decryptMsg2 (char msg[MAX_PAYLOAD_SIZE+1]) Decrypts a message string using the AES256 algorythm with the corresponding node key. void onReceive (int packetSize) Called every time a new message is received. Filters unwanted messages, decrypts the payload, gets the relevant fields from the payload and sends back an acknowledge message if necessary. void onTxDone () String splitAndEncrypt (char msg[MAX_PAYLOAD_SIZE]) void sendSensorData (byte sensorID, byte sensorVal) Adds to the message queue an uplink message containing sensor data. void getMsgFromQueueAndSend (unsigned long currentMillis) Get a message from the send queue and send it. Implements retransmission in case an acknowledge message is not received. Aware of a failed transmission. void sendStatus (byte msgID) Send an uplink message containing the node status. void sendAck (byte msgID) Send an acknowledge message confirming the reception of an uplink transmission. void setActState (int ID, int val) Sets the state of the relevant actuator with the relevant value. int mymin (int a, int b) returns the minimum value between two integers","title":"Functions"},{"location":"Node/Files/comms__protocol_8h/#attributes","text":"Name const uint8_t keyBroadcast const long frequency const int txPower const int spreadingFactor const long signalBandwidth const int codingRateDenominator int currMsg int count unsigned long prevMil unsigned long prevMilSU int msgCount cppQueue msg_q aes256_context ctxt","title":"Attributes"},{"location":"Node/Files/comms__protocol_8h/#defines","text":"Name IMPLEMENTATION MAX_N_RETRY TIMEOUT_INTERVAL MAX_QUEUE_SIZE BLOCK_SIZE MAX_PAYLOAD_SIZE ENC_BLOCK_SIZE MAX_ENC_PAYLOAD_SIZE MAX_MSG_ID STATUS_UPDATE_INTERVAL BROADCAST_ID","title":"Defines"},{"location":"Node/Files/comms__protocol_8h/#detailed-description","text":"Header file for the communication protocol library. Contains the used data structures, function declaration and general configuartion options for the library. Author : Francisco Santos ( francisco.velez@tecnico.ulisboa.pt ) Version : 1.0 Date : 2022-08-10 Copyright : Copyright (c) 2022","title":"Detailed Description"},{"location":"Node/Files/comms__protocol_8h/#types-documentation","text":"","title":"Types Documentation"},{"location":"Node/Files/comms__protocol_8h/#typedef-payload","text":"typedef struct strPayload Payload;","title":"typedef Payload"},{"location":"Node/Files/comms__protocol_8h/#typedef-msg","text":"typedef struct strMsg Msg;","title":"typedef Msg"},{"location":"Node/Files/comms__protocol_8h/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Node/Files/comms__protocol_8h/#function-lora_rxmode","text":"void LoRa_rxMode() Sets the LoRa radio to receive mode. Return : void","title":"function LoRa_rxMode"},{"location":"Node/Files/comms__protocol_8h/#function-lora_txmode","text":"void LoRa_txMode() Sets the LoRa radio to transmit mode. Return : void","title":"function LoRa_txMode"},{"location":"Node/Files/comms__protocol_8h/#function-lora_sendmessage","text":"void LoRa_sendMessage( byte * message ) Sets the radio to transmit mode, sends a message string using the LoRa radio and sets the radio back to receive mode. Parameters : message message to send Return : void","title":"function LoRa_sendMessage"},{"location":"Node/Files/comms__protocol_8h/#function-decryptmsg","text":"char * decryptMsg( String msg )","title":"function decryptMsg"},{"location":"Node/Files/comms__protocol_8h/#function-decryptmsg2","text":"char * decryptMsg2( char msg[MAX_PAYLOAD_SIZE+1] ) Decrypts a message string using the AES256 algorythm with the corresponding node key. Parameters : msg message string to be decrypted Return : char* an array of characters containing the decrypted message","title":"function decryptMsg2"},{"location":"Node/Files/comms__protocol_8h/#function-onreceive","text":"void onReceive( int packetSize ) Called every time a new message is received. Filters unwanted messages, decrypts the payload, gets the relevant fields from the payload and sends back an acknowledge message if necessary. Parameters : packetSize size of the incoming message in bytes Return : void","title":"function onReceive"},{"location":"Node/Files/comms__protocol_8h/#function-ontxdone","text":"void onTxDone()","title":"function onTxDone"},{"location":"Node/Files/comms__protocol_8h/#function-splitandencrypt","text":"String splitAndEncrypt( char msg[MAX_PAYLOAD_SIZE] )","title":"function splitAndEncrypt"},{"location":"Node/Files/comms__protocol_8h/#function-sendsensordata","text":"void sendSensorData( byte sensorID, byte sensorVal ) Adds to the message queue an uplink message containing sensor data. Parameters : sensorID ID of the relevant sensor sensorVal value read from the relevant sensor Return : void Note: The ADC value is a 12-bit number, so the maximum value is 4095 (counting from 0). To convert the ADC integer value to a real voltage you\u2019ll need to divide it by the maximum value of 4095, then double it (note above that Adafruit halves the voltage), then multiply that by the reference voltage of the ESP32 which is 3.3V and then vinally, multiply that again by the ADC Reference Voltage of 1100mV.","title":"function sendSensorData"},{"location":"Node/Files/comms__protocol_8h/#function-getmsgfromqueueandsend","text":"void getMsgFromQueueAndSend( unsigned long currentMillis ) Get a message from the send queue and send it. Implements retransmission in case an acknowledge message is not received. Aware of a failed transmission. Parameters : currentMillis current time in millisenconds since boot Return : void","title":"function getMsgFromQueueAndSend"},{"location":"Node/Files/comms__protocol_8h/#function-sendstatus","text":"void sendStatus( byte msgID ) Send an uplink message containing the node status. Parameters : msgID ID of the status request message Return : void","title":"function sendStatus"},{"location":"Node/Files/comms__protocol_8h/#function-sendack","text":"void sendAck( byte msgID ) Send an acknowledge message confirming the reception of an uplink transmission. Parameters : msgID ID of the message being acknowledged Return : void","title":"function sendAck"},{"location":"Node/Files/comms__protocol_8h/#function-setactstate","text":"void setActState( int ID, int val ) Sets the state of the relevant actuator with the relevant value. Parameters : ID ID of the relevant actuator val value to which the actuator is set to Return : void","title":"function setActState"},{"location":"Node/Files/comms__protocol_8h/#function-mymin","text":"int mymin( int a, int b ) returns the minimum value between two integers Parameters : a first integer to compare b second integer to compare Return : int the smaller between a and b","title":"function mymin"},{"location":"Node/Files/comms__protocol_8h/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Node/Files/comms__protocol_8h/#variable-keybroadcast","text":"const uint8_t keyBroadcast = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x0f };","title":"variable keyBroadcast"},{"location":"Node/Files/comms__protocol_8h/#variable-frequency","text":"const long frequency = 868E6;","title":"variable frequency"},{"location":"Node/Files/comms__protocol_8h/#variable-txpower","text":"const int txPower = 14;","title":"variable txPower"},{"location":"Node/Files/comms__protocol_8h/#variable-spreadingfactor","text":"const int spreadingFactor = 7;","title":"variable spreadingFactor"},{"location":"Node/Files/comms__protocol_8h/#variable-signalbandwidth","text":"const long signalBandwidth = 125E3;","title":"variable signalBandwidth"},{"location":"Node/Files/comms__protocol_8h/#variable-codingratedenominator","text":"const int codingRateDenominator = 5;","title":"variable codingRateDenominator"},{"location":"Node/Files/comms__protocol_8h/#variable-currmsg","text":"int currMsg;","title":"variable currMsg"},{"location":"Node/Files/comms__protocol_8h/#variable-count","text":"int count;","title":"variable count"},{"location":"Node/Files/comms__protocol_8h/#variable-prevmil","text":"unsigned long prevMil;","title":"variable prevMil"},{"location":"Node/Files/comms__protocol_8h/#variable-prevmilsu","text":"unsigned long prevMilSU;","title":"variable prevMilSU"},{"location":"Node/Files/comms__protocol_8h/#variable-msgcount","text":"int msgCount;","title":"variable msgCount"},{"location":"Node/Files/comms__protocol_8h/#variable-msg_q","text":"cppQueue msg_q;","title":"variable msg_q"},{"location":"Node/Files/comms__protocol_8h/#variable-ctxt","text":"aes256_context ctxt;","title":"variable ctxt"},{"location":"Node/Files/comms__protocol_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"Node/Files/comms__protocol_8h/#define-implementation","text":"#define IMPLEMENTATION FIFO","title":"define IMPLEMENTATION"},{"location":"Node/Files/comms__protocol_8h/#define-max_n_retry","text":"#define MAX_N_RETRY 3","title":"define MAX_N_RETRY"},{"location":"Node/Files/comms__protocol_8h/#define-timeout_interval","text":"#define TIMEOUT_INTERVAL 1000","title":"define TIMEOUT_INTERVAL"},{"location":"Node/Files/comms__protocol_8h/#define-max_queue_size","text":"#define MAX_QUEUE_SIZE 5","title":"define MAX_QUEUE_SIZE"},{"location":"Node/Files/comms__protocol_8h/#define-block_size","text":"#define BLOCK_SIZE 16","title":"define BLOCK_SIZE"},{"location":"Node/Files/comms__protocol_8h/#define-max_payload_size","text":"#define MAX_PAYLOAD_SIZE 16","title":"define MAX_PAYLOAD_SIZE"},{"location":"Node/Files/comms__protocol_8h/#define-enc_block_size","text":"#define ENC_BLOCK_SIZE (1*BLOCK_SIZE)","title":"define ENC_BLOCK_SIZE"},{"location":"Node/Files/comms__protocol_8h/#define-max_enc_payload_size","text":"#define MAX_ENC_PAYLOAD_SIZE ((MAX_PAYLOAD_SIZE/BLOCK_SIZE)*ENC_BLOCK_SIZE)+1","title":"define MAX_ENC_PAYLOAD_SIZE"},{"location":"Node/Files/comms__protocol_8h/#define-max_msg_id","text":"#define MAX_MSG_ID 256","title":"define MAX_MSG_ID"},{"location":"Node/Files/comms__protocol_8h/#define-status_update_interval","text":"#define STATUS_UPDATE_INTERVAL 60000","title":"define STATUS_UPDATE_INTERVAL"},{"location":"Node/Files/comms__protocol_8h/#define-broadcast_id","text":"#define BROADCAST_ID 0xFF","title":"define BROADCAST_ID"},{"location":"Node/Files/comms__protocol_8h/#source-code","text":"#ifndef COMMS_PROTOCOL_H #define COMMS_PROTOCOL_H #include <Arduino.h> #include <SPI.h> #include <LoRa.h> #include <cppQueue.h> #include <aes256.h> #include \"node_definitions.h\" #define IMPLEMENTATION FIFO // LoRa msg payload settings #define MAX_N_RETRY 3 #define TIMEOUT_INTERVAL 1000 #define MAX_QUEUE_SIZE 5 #define BLOCK_SIZE 16 #define MAX_PAYLOAD_SIZE 16 #define ENC_BLOCK_SIZE (1*BLOCK_SIZE) #define MAX_ENC_PAYLOAD_SIZE ((MAX_PAYLOAD_SIZE/BLOCK_SIZE)*ENC_BLOCK_SIZE)+1 #define MAX_MSG_ID 256 #define STATUS_UPDATE_INTERVAL 60000 #define BROADCAST_ID 0xFF // Broadcast Encryption key const uint8_t keyBroadcast[] = { // 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x0f }; // LoRa Modem Settings const long frequency = 868E6; const int txPower = 14; const int spreadingFactor = 7; const long signalBandwidth = 125E3; const int codingRateDenominator = 5; typedef struct strPayload { byte nodeID; byte sensorID; byte msgID; char flag; byte sensorVal; int RSSI; float SNR; } Payload; typedef struct strMsg { byte msg[MAX_ENC_PAYLOAD_SIZE]; byte msgID; char flag; } Msg; extern int currMsg; extern int count; extern unsigned long prevMil; extern unsigned long prevMilSU; extern int msgCount; extern cppQueue msg_q; extern aes256_context ctxt; void LoRa_rxMode(); void LoRa_txMode(); void LoRa_sendMessage(byte *message); char *decryptMsg(String msg); char *decryptMsg2(char msg[MAX_PAYLOAD_SIZE+1]); void onReceive(int packetSize); void onTxDone(); String splitAndEncrypt(char msg[MAX_PAYLOAD_SIZE]); void sendSensorData(byte sensorID, byte sensorVal); void getMsgFromQueueAndSend(unsigned long currentMillis); void sendStatus(byte msgID); void sendAck(byte msgID); void setActState(int ID, int val); int mymin(int a, int b); #endif Updated on 2022-08-25 at 10:49:36 +0000","title":"Source code"},{"location":"Node/Files/dir_bbe80895da9089dc2b343d9c86835d12/","text":"/sensor_network/node/node_definitions Files Name /sensor_network/node/node_definitions/node_definitions_1.h Definitions for node with id 1. /sensor_network/node/node_definitions/node_definitions_2.h Definitions for node with id 2. /sensor_network/node/node_definitions/node_definitions_3.h Definitions for node with id 3. /sensor_network/node/node_definitions/node_definitions_4.h Definitions for node with id 4. /sensor_network/node/node_definitions/node_definitions_uno.h Definitions for node with id 1. Updated on 2022-08-25 at 10:49:36 +0000","title":"/sensor_network/node/node_definitions"},{"location":"Node/Files/dir_bbe80895da9089dc2b343d9c86835d12/#sensor_networknodenode_definitions","text":"","title":"/sensor_network/node/node_definitions"},{"location":"Node/Files/dir_bbe80895da9089dc2b343d9c86835d12/#files","text":"Name /sensor_network/node/node_definitions/node_definitions_1.h Definitions for node with id 1. /sensor_network/node/node_definitions/node_definitions_2.h Definitions for node with id 2. /sensor_network/node/node_definitions/node_definitions_3.h Definitions for node with id 3. /sensor_network/node/node_definitions/node_definitions_4.h Definitions for node with id 4. /sensor_network/node/node_definitions/node_definitions_uno.h Definitions for node with id 1. Updated on 2022-08-25 at 10:49:36 +0000","title":"Files"},{"location":"Node/Files/node_8ino/","text":"node.ino Node script - send sensor data to gateway and receive commands from gateway. More... Functions Name void setup () Arduino setup function. void loop () Arduino loop function. Detailed Description Node script - send sensor data to gateway and receive commands from gateway. Author : Francisco Santos ( francisco.velez@tecnico.ulisboa.pt ) Version : 1.0 Date : 2022-08-09 Copyright : Copyright (c) 2022 Functions Documentation function setup void setup() Arduino setup function. Function: setup Runs once at boot. Configure the serial communication. Configure the LoRa radio. Configure the sensors and actuators input mode void function loop void loop() Arduino loop function. Function: loop Main loop function. checks for incoming uplink messages and downlink requests from the server. calls getMsgFromQueueAndSend on fixed schedules to avoid congestion of the communication channel and sends an uplink message with the node status periodically. void Source code #include \"comms_protocol.h\" void setup() { for(int i=0; i<sensN; i++){ pinMode(sensPin[i], INPUT); } for(int i=0; i<actN; i++){ pinMode(actPin[i], OUTPUT); } Serial.begin(BAUD_RATE); #if defined(ESP32) SPI.begin(SCK, MISO, MOSI, SS); #endif //LoRa.setTxPower(txPower); //LoRa.setSignalBandwidth(signalBandwidth); //LoRa.setCodingRate4(codingRateDenominator); LoRa.setPins(SS, RST, DIO0); if (!LoRa.begin(frequency)) { Serial.println(\"LoRa init failed.\"); while (true); } LoRa.setSpreadingFactor(7); LoRa.setCodingRate4(8); LoRa.setSyncWord(netID); LoRa.enableCrc(); LoRa_rxMode(); prevMil = millis(); prevMilSU = millis(); Serial.println(\"Node startup complete\"); sendSensorData(0, 3); } void loop() { unsigned long currentMillis = millis(); // Receive Downlink msg int packetSize = LoRa.parsePacket(); if (packetSize) { onReceive(packetSize); } // Send Uplink msg if((currentMillis-prevMil) > TIMEOUT_INTERVAL){ getMsgFromQueueAndSend(currentMillis); } // Send node status if((currentMillis-prevMilSU) > STATUS_UPDATE_INTERVAL){ byte msgID = random(MAX_MSG_ID); //sendStatus(msgID); prevMilSU = currentMillis; } } Updated on 2022-08-25 at 10:49:36 +0000","title":"node.ino"},{"location":"Node/Files/node_8ino/#nodeino","text":"Node script - send sensor data to gateway and receive commands from gateway. More...","title":"node.ino"},{"location":"Node/Files/node_8ino/#functions","text":"Name void setup () Arduino setup function. void loop () Arduino loop function.","title":"Functions"},{"location":"Node/Files/node_8ino/#detailed-description","text":"Node script - send sensor data to gateway and receive commands from gateway. Author : Francisco Santos ( francisco.velez@tecnico.ulisboa.pt ) Version : 1.0 Date : 2022-08-09 Copyright : Copyright (c) 2022","title":"Detailed Description"},{"location":"Node/Files/node_8ino/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Node/Files/node_8ino/#function-setup","text":"void setup() Arduino setup function.","title":"function setup"},{"location":"Node/Files/node_8ino/#function-setup_1","text":"Runs once at boot. Configure the serial communication. Configure the LoRa radio. Configure the sensors and actuators input mode void","title":"Function: setup"},{"location":"Node/Files/node_8ino/#function-loop","text":"void loop() Arduino loop function.","title":"function loop"},{"location":"Node/Files/node_8ino/#function-loop_1","text":"Main loop function. checks for incoming uplink messages and downlink requests from the server. calls getMsgFromQueueAndSend on fixed schedules to avoid congestion of the communication channel and sends an uplink message with the node status periodically. void","title":"Function: loop"},{"location":"Node/Files/node_8ino/#source-code","text":"#include \"comms_protocol.h\" void setup() { for(int i=0; i<sensN; i++){ pinMode(sensPin[i], INPUT); } for(int i=0; i<actN; i++){ pinMode(actPin[i], OUTPUT); } Serial.begin(BAUD_RATE); #if defined(ESP32) SPI.begin(SCK, MISO, MOSI, SS); #endif //LoRa.setTxPower(txPower); //LoRa.setSignalBandwidth(signalBandwidth); //LoRa.setCodingRate4(codingRateDenominator); LoRa.setPins(SS, RST, DIO0); if (!LoRa.begin(frequency)) { Serial.println(\"LoRa init failed.\"); while (true); } LoRa.setSpreadingFactor(7); LoRa.setCodingRate4(8); LoRa.setSyncWord(netID); LoRa.enableCrc(); LoRa_rxMode(); prevMil = millis(); prevMilSU = millis(); Serial.println(\"Node startup complete\"); sendSensorData(0, 3); } void loop() { unsigned long currentMillis = millis(); // Receive Downlink msg int packetSize = LoRa.parsePacket(); if (packetSize) { onReceive(packetSize); } // Send Uplink msg if((currentMillis-prevMil) > TIMEOUT_INTERVAL){ getMsgFromQueueAndSend(currentMillis); } // Send node status if((currentMillis-prevMilSU) > STATUS_UPDATE_INTERVAL){ byte msgID = random(MAX_MSG_ID); //sendStatus(msgID); prevMilSU = currentMillis; } } Updated on 2022-08-25 at 10:49:36 +0000","title":"Source code"},{"location":"Node/Files/node__definitions_8h/","text":"node_definitions.h Header file for the node program. Contains hardware pinouts, LoRa modem configs and node settings. More... Attributes Name const byte netID const int sensN const int actN Defines Name BAUD_RATE Detailed Description Header file for the node program. Contains hardware pinouts, LoRa modem configs and node settings. Author : Francisco Santos ( francisco.velez@tecnico.ulisboa.pt ) Version : 1.0 Date : 2022-08-10 Copyright : Copyright (c) 2022 Attributes Documentation variable netID const byte netID = 0xF3; variable sensN const int sensN = sizeof(sensPin)/sizeof(int); variable actN const int actN = sizeof(actPin)/sizeof(int); Macros Documentation define BAUD_RATE #define BAUD_RATE 115200 Source code #ifndef NODE_DEFINITIONS_H #define NODE_DEFINITIONS_H // Baud rate for serial communication #define BAUD_RATE 115200 // Node Settings const byte netID = 0xF3; #include \"node_definitions/node_definitions_3.h\" const int sensN = sizeof(sensPin)/sizeof(int); const int actN = sizeof(actPin)/sizeof(int); #endif Updated on 2022-08-25 at 10:49:36 +0000","title":"node_definitions.h"},{"location":"Node/Files/node__definitions_8h/#node_definitionsh","text":"Header file for the node program. Contains hardware pinouts, LoRa modem configs and node settings. More...","title":"node_definitions.h"},{"location":"Node/Files/node__definitions_8h/#attributes","text":"Name const byte netID const int sensN const int actN","title":"Attributes"},{"location":"Node/Files/node__definitions_8h/#defines","text":"Name BAUD_RATE","title":"Defines"},{"location":"Node/Files/node__definitions_8h/#detailed-description","text":"Header file for the node program. Contains hardware pinouts, LoRa modem configs and node settings. Author : Francisco Santos ( francisco.velez@tecnico.ulisboa.pt ) Version : 1.0 Date : 2022-08-10 Copyright : Copyright (c) 2022","title":"Detailed Description"},{"location":"Node/Files/node__definitions_8h/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Node/Files/node__definitions_8h/#variable-netid","text":"const byte netID = 0xF3;","title":"variable netID"},{"location":"Node/Files/node__definitions_8h/#variable-sensn","text":"const int sensN = sizeof(sensPin)/sizeof(int);","title":"variable sensN"},{"location":"Node/Files/node__definitions_8h/#variable-actn","text":"const int actN = sizeof(actPin)/sizeof(int);","title":"variable actN"},{"location":"Node/Files/node__definitions_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"Node/Files/node__definitions_8h/#define-baud_rate","text":"#define BAUD_RATE 115200","title":"define BAUD_RATE"},{"location":"Node/Files/node__definitions_8h/#source-code","text":"#ifndef NODE_DEFINITIONS_H #define NODE_DEFINITIONS_H // Baud rate for serial communication #define BAUD_RATE 115200 // Node Settings const byte netID = 0xF3; #include \"node_definitions/node_definitions_3.h\" const int sensN = sizeof(sensPin)/sizeof(int); const int actN = sizeof(actPin)/sizeof(int); #endif Updated on 2022-08-25 at 10:49:36 +0000","title":"Source code"},{"location":"Node/Files/node__definitions__1_8h/","text":"/sensor_network/node/node_definitions/node_definitions_1.h Definitions for node with id 1. More... Attributes Name const uint8_t key const byte nodeID const int vbatPin const int sensPin const int actPin Defines Name SCK MISO MOSI SS RST DIO0 Detailed Description Definitions for node with id 1. Author : Francisco Santos ( francisco.velez@tecnico.ulisboa.pt ) Version : 1.0 Date : 2022-08-10 Copyright : Copyright (c) 2022 Attributes Documentation variable key const uint8_t key = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f }; variable nodeID const byte nodeID = 0x01; variable vbatPin const int vbatPin = 35; variable sensPin const int sensPin = {16}; variable actPin const int actPin = {LED_BUILTIN}; Macros Documentation define SCK #define SCK 5 define MISO #define MISO 19 define MOSI #define MOSI 27 define SS #define SS 18 define RST #define RST 14 define DIO0 #define DIO0 26 Source code #ifndef NODE_DEFINITIONS_1_H #define NODE_DEFINITIONS_1_H // Node Encryption key const uint8_t key[] = { // 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f }; // SPI pinout for TTGO boards #define SCK 5 #define MISO 19 #define MOSI 27 // LoRa Modem Pinout for TTGO boards #define SS 18 #define RST 14 #define DIO0 26 // Node Settings const byte nodeID = 0x01; // Node I/O Pinout const int vbatPin = 35; const int sensPin[] = {16}; const int actPin[] = {LED_BUILTIN}; #endif Updated on 2022-08-25 at 10:49:36 +0000","title":"/sensor_network/node/node_definitions/node_definitions_1.h"},{"location":"Node/Files/node__definitions__1_8h/#sensor_networknodenode_definitionsnode_definitions_1h","text":"Definitions for node with id 1. More...","title":"/sensor_network/node/node_definitions/node_definitions_1.h"},{"location":"Node/Files/node__definitions__1_8h/#attributes","text":"Name const uint8_t key const byte nodeID const int vbatPin const int sensPin const int actPin","title":"Attributes"},{"location":"Node/Files/node__definitions__1_8h/#defines","text":"Name SCK MISO MOSI SS RST DIO0","title":"Defines"},{"location":"Node/Files/node__definitions__1_8h/#detailed-description","text":"Definitions for node with id 1. Author : Francisco Santos ( francisco.velez@tecnico.ulisboa.pt ) Version : 1.0 Date : 2022-08-10 Copyright : Copyright (c) 2022","title":"Detailed Description"},{"location":"Node/Files/node__definitions__1_8h/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Node/Files/node__definitions__1_8h/#variable-key","text":"const uint8_t key = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f };","title":"variable key"},{"location":"Node/Files/node__definitions__1_8h/#variable-nodeid","text":"const byte nodeID = 0x01;","title":"variable nodeID"},{"location":"Node/Files/node__definitions__1_8h/#variable-vbatpin","text":"const int vbatPin = 35;","title":"variable vbatPin"},{"location":"Node/Files/node__definitions__1_8h/#variable-senspin","text":"const int sensPin = {16};","title":"variable sensPin"},{"location":"Node/Files/node__definitions__1_8h/#variable-actpin","text":"const int actPin = {LED_BUILTIN};","title":"variable actPin"},{"location":"Node/Files/node__definitions__1_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"Node/Files/node__definitions__1_8h/#define-sck","text":"#define SCK 5","title":"define SCK"},{"location":"Node/Files/node__definitions__1_8h/#define-miso","text":"#define MISO 19","title":"define MISO"},{"location":"Node/Files/node__definitions__1_8h/#define-mosi","text":"#define MOSI 27","title":"define MOSI"},{"location":"Node/Files/node__definitions__1_8h/#define-ss","text":"#define SS 18","title":"define SS"},{"location":"Node/Files/node__definitions__1_8h/#define-rst","text":"#define RST 14","title":"define RST"},{"location":"Node/Files/node__definitions__1_8h/#define-dio0","text":"#define DIO0 26","title":"define DIO0"},{"location":"Node/Files/node__definitions__1_8h/#source-code","text":"#ifndef NODE_DEFINITIONS_1_H #define NODE_DEFINITIONS_1_H // Node Encryption key const uint8_t key[] = { // 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f }; // SPI pinout for TTGO boards #define SCK 5 #define MISO 19 #define MOSI 27 // LoRa Modem Pinout for TTGO boards #define SS 18 #define RST 14 #define DIO0 26 // Node Settings const byte nodeID = 0x01; // Node I/O Pinout const int vbatPin = 35; const int sensPin[] = {16}; const int actPin[] = {LED_BUILTIN}; #endif Updated on 2022-08-25 at 10:49:36 +0000","title":"Source code"},{"location":"Node/Files/node__definitions__2_8h/","text":"/sensor_network/node/node_definitions/node_definitions_2.h Definitions for node with id 2. More... Attributes Name const uint8_t key const byte nodeID const int vbatPin const int sensPin const int actPin Defines Name SCK MISO MOSI SS RST DIO0 Detailed Description Definitions for node with id 2. Author : Francisco Santos ( francisco.velez@tecnico.ulisboa.pt ) Version : 1.0 Date : 2022-08-10 Copyright : Copyright (c) 2022 Attributes Documentation variable key const uint8_t key = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x2f }; variable nodeID const byte nodeID = 0x02; variable vbatPin const int vbatPin = 35; variable sensPin const int sensPin = {16}; variable actPin const int actPin = {LED_BUILTIN}; Macros Documentation define SCK #define SCK 5 define MISO #define MISO 19 define MOSI #define MOSI 27 define SS #define SS 18 define RST #define RST 14 define DIO0 #define DIO0 26 Source code #ifndef NODE_DEFINITIONS_2_H #define NODE_DEFINITIONS_2_H // Node Encryption key const uint8_t key[] = { // 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x2f }; // SPI pinout for TTGO boards #define SCK 5 #define MISO 19 #define MOSI 27 // LoRa Modem Pinout for TTGO boards #define SS 18 #define RST 14 #define DIO0 26 // Node Settings const byte nodeID = 0x02; // Node I/O Pinout const int vbatPin = 35; const int sensPin[] = {16}; const int actPin[] = {LED_BUILTIN}; #endif Updated on 2022-08-25 at 10:49:36 +0000","title":"/sensor_network/node/node_definitions/node_definitions_2.h"},{"location":"Node/Files/node__definitions__2_8h/#sensor_networknodenode_definitionsnode_definitions_2h","text":"Definitions for node with id 2. More...","title":"/sensor_network/node/node_definitions/node_definitions_2.h"},{"location":"Node/Files/node__definitions__2_8h/#attributes","text":"Name const uint8_t key const byte nodeID const int vbatPin const int sensPin const int actPin","title":"Attributes"},{"location":"Node/Files/node__definitions__2_8h/#defines","text":"Name SCK MISO MOSI SS RST DIO0","title":"Defines"},{"location":"Node/Files/node__definitions__2_8h/#detailed-description","text":"Definitions for node with id 2. Author : Francisco Santos ( francisco.velez@tecnico.ulisboa.pt ) Version : 1.0 Date : 2022-08-10 Copyright : Copyright (c) 2022","title":"Detailed Description"},{"location":"Node/Files/node__definitions__2_8h/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Node/Files/node__definitions__2_8h/#variable-key","text":"const uint8_t key = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x2f };","title":"variable key"},{"location":"Node/Files/node__definitions__2_8h/#variable-nodeid","text":"const byte nodeID = 0x02;","title":"variable nodeID"},{"location":"Node/Files/node__definitions__2_8h/#variable-vbatpin","text":"const int vbatPin = 35;","title":"variable vbatPin"},{"location":"Node/Files/node__definitions__2_8h/#variable-senspin","text":"const int sensPin = {16};","title":"variable sensPin"},{"location":"Node/Files/node__definitions__2_8h/#variable-actpin","text":"const int actPin = {LED_BUILTIN};","title":"variable actPin"},{"location":"Node/Files/node__definitions__2_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"Node/Files/node__definitions__2_8h/#define-sck","text":"#define SCK 5","title":"define SCK"},{"location":"Node/Files/node__definitions__2_8h/#define-miso","text":"#define MISO 19","title":"define MISO"},{"location":"Node/Files/node__definitions__2_8h/#define-mosi","text":"#define MOSI 27","title":"define MOSI"},{"location":"Node/Files/node__definitions__2_8h/#define-ss","text":"#define SS 18","title":"define SS"},{"location":"Node/Files/node__definitions__2_8h/#define-rst","text":"#define RST 14","title":"define RST"},{"location":"Node/Files/node__definitions__2_8h/#define-dio0","text":"#define DIO0 26","title":"define DIO0"},{"location":"Node/Files/node__definitions__2_8h/#source-code","text":"#ifndef NODE_DEFINITIONS_2_H #define NODE_DEFINITIONS_2_H // Node Encryption key const uint8_t key[] = { // 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x2f }; // SPI pinout for TTGO boards #define SCK 5 #define MISO 19 #define MOSI 27 // LoRa Modem Pinout for TTGO boards #define SS 18 #define RST 14 #define DIO0 26 // Node Settings const byte nodeID = 0x02; // Node I/O Pinout const int vbatPin = 35; const int sensPin[] = {16}; const int actPin[] = {LED_BUILTIN}; #endif Updated on 2022-08-25 at 10:49:36 +0000","title":"Source code"},{"location":"Node/Files/node__definitions__3_8h/","text":"/sensor_network/node/node_definitions/node_definitions_3.h Definitions for node with id 3. More... Attributes Name const uint8_t key const byte nodeID const int vbatPin const int sensPin const int actPin Defines Name SCK MISO MOSI SS RST DIO0 Detailed Description Definitions for node with id 3. Author : Francisco Santos ( francisco.velez@tecnico.ulisboa.pt ) Version : 1.0 Date : 2022-08-10 Copyright : Copyright (c) 2022 Attributes Documentation variable key const uint8_t key = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x3f }; variable nodeID const byte nodeID = 0x03; variable vbatPin const int vbatPin = 35; variable sensPin const int sensPin = {16}; variable actPin const int actPin = {LED_BUILTIN}; Macros Documentation define SCK #define SCK 5 define MISO #define MISO 19 define MOSI #define MOSI 27 define SS #define SS 18 define RST #define RST 14 define DIO0 #define DIO0 26 Source code #ifndef NODE_DEFINITIONS_3_H #define NODE_DEFINITIONS_3_H // Node Encryption key const uint8_t key[] = { // 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x3f }; // SPI pinout for TTGO boards #define SCK 5 #define MISO 19 #define MOSI 27 // LoRa Modem Pinout for TTGO boards #define SS 18 #define RST 14 #define DIO0 26 // Node Settings const byte nodeID = 0x03; // Node I/O Pinout const int vbatPin = 35; const int sensPin[] = {16}; const int actPin[] = {LED_BUILTIN}; #endif Updated on 2022-08-25 at 10:49:36 +0000","title":"/sensor_network/node/node_definitions/node_definitions_3.h"},{"location":"Node/Files/node__definitions__3_8h/#sensor_networknodenode_definitionsnode_definitions_3h","text":"Definitions for node with id 3. More...","title":"/sensor_network/node/node_definitions/node_definitions_3.h"},{"location":"Node/Files/node__definitions__3_8h/#attributes","text":"Name const uint8_t key const byte nodeID const int vbatPin const int sensPin const int actPin","title":"Attributes"},{"location":"Node/Files/node__definitions__3_8h/#defines","text":"Name SCK MISO MOSI SS RST DIO0","title":"Defines"},{"location":"Node/Files/node__definitions__3_8h/#detailed-description","text":"Definitions for node with id 3. Author : Francisco Santos ( francisco.velez@tecnico.ulisboa.pt ) Version : 1.0 Date : 2022-08-10 Copyright : Copyright (c) 2022","title":"Detailed Description"},{"location":"Node/Files/node__definitions__3_8h/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Node/Files/node__definitions__3_8h/#variable-key","text":"const uint8_t key = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x3f };","title":"variable key"},{"location":"Node/Files/node__definitions__3_8h/#variable-nodeid","text":"const byte nodeID = 0x03;","title":"variable nodeID"},{"location":"Node/Files/node__definitions__3_8h/#variable-vbatpin","text":"const int vbatPin = 35;","title":"variable vbatPin"},{"location":"Node/Files/node__definitions__3_8h/#variable-senspin","text":"const int sensPin = {16};","title":"variable sensPin"},{"location":"Node/Files/node__definitions__3_8h/#variable-actpin","text":"const int actPin = {LED_BUILTIN};","title":"variable actPin"},{"location":"Node/Files/node__definitions__3_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"Node/Files/node__definitions__3_8h/#define-sck","text":"#define SCK 5","title":"define SCK"},{"location":"Node/Files/node__definitions__3_8h/#define-miso","text":"#define MISO 19","title":"define MISO"},{"location":"Node/Files/node__definitions__3_8h/#define-mosi","text":"#define MOSI 27","title":"define MOSI"},{"location":"Node/Files/node__definitions__3_8h/#define-ss","text":"#define SS 18","title":"define SS"},{"location":"Node/Files/node__definitions__3_8h/#define-rst","text":"#define RST 14","title":"define RST"},{"location":"Node/Files/node__definitions__3_8h/#define-dio0","text":"#define DIO0 26","title":"define DIO0"},{"location":"Node/Files/node__definitions__3_8h/#source-code","text":"#ifndef NODE_DEFINITIONS_3_H #define NODE_DEFINITIONS_3_H // Node Encryption key const uint8_t key[] = { // 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x3f }; // SPI pinout for TTGO boards #define SCK 5 #define MISO 19 #define MOSI 27 // LoRa Modem Pinout for TTGO boards #define SS 18 #define RST 14 #define DIO0 26 // Node Settings const byte nodeID = 0x03; // Node I/O Pinout const int vbatPin = 35; const int sensPin[] = {16}; const int actPin[] = {LED_BUILTIN}; #endif Updated on 2022-08-25 at 10:49:36 +0000","title":"Source code"},{"location":"Node/Files/node__definitions__4_8h/","text":"/sensor_network/node/node_definitions/node_definitions_4.h Definitions for node with id 4. More... Attributes Name const uint8_t key const byte nodeID const int vbatPin const int sensPin const int actPin Defines Name SCK MISO MOSI SS RST DIO0 Detailed Description Definitions for node with id 4. Author : Francisco Santos ( francisco.velez@tecnico.ulisboa.pt ) Version : 1.0 Date : 2022-08-10 Copyright : Copyright (c) 2022 Attributes Documentation variable key const uint8_t key = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x4f }; variable nodeID const byte nodeID = 0x04; variable vbatPin const int vbatPin = 35; variable sensPin const int sensPin = {16}; variable actPin const int actPin = {LED_BUILTIN}; Macros Documentation define SCK #define SCK 5 define MISO #define MISO 19 define MOSI #define MOSI 27 define SS #define SS 18 define RST #define RST 14 define DIO0 #define DIO0 26 Source code #ifndef NODE_DEFINITIONS_4_H #define NODE_DEFINITIONS_4_H // Node Encryption key const uint8_t key[] = { // 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x4f }; // SPI pinout for TTGO boards #define SCK 5 #define MISO 19 #define MOSI 27 // LoRa Modem Pinout for TTGO boards #define SS 18 #define RST 14 #define DIO0 26 // Node Settings const byte nodeID = 0x04; // Node I/O Pinout const int vbatPin = 35; const int sensPin[] = {16}; const int actPin[] = {LED_BUILTIN}; #endif Updated on 2022-08-25 at 10:49:36 +0000","title":"/sensor_network/node/node_definitions/node_definitions_4.h"},{"location":"Node/Files/node__definitions__4_8h/#sensor_networknodenode_definitionsnode_definitions_4h","text":"Definitions for node with id 4. More...","title":"/sensor_network/node/node_definitions/node_definitions_4.h"},{"location":"Node/Files/node__definitions__4_8h/#attributes","text":"Name const uint8_t key const byte nodeID const int vbatPin const int sensPin const int actPin","title":"Attributes"},{"location":"Node/Files/node__definitions__4_8h/#defines","text":"Name SCK MISO MOSI SS RST DIO0","title":"Defines"},{"location":"Node/Files/node__definitions__4_8h/#detailed-description","text":"Definitions for node with id 4. Author : Francisco Santos ( francisco.velez@tecnico.ulisboa.pt ) Version : 1.0 Date : 2022-08-10 Copyright : Copyright (c) 2022","title":"Detailed Description"},{"location":"Node/Files/node__definitions__4_8h/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Node/Files/node__definitions__4_8h/#variable-key","text":"const uint8_t key = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x4f };","title":"variable key"},{"location":"Node/Files/node__definitions__4_8h/#variable-nodeid","text":"const byte nodeID = 0x04;","title":"variable nodeID"},{"location":"Node/Files/node__definitions__4_8h/#variable-vbatpin","text":"const int vbatPin = 35;","title":"variable vbatPin"},{"location":"Node/Files/node__definitions__4_8h/#variable-senspin","text":"const int sensPin = {16};","title":"variable sensPin"},{"location":"Node/Files/node__definitions__4_8h/#variable-actpin","text":"const int actPin = {LED_BUILTIN};","title":"variable actPin"},{"location":"Node/Files/node__definitions__4_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"Node/Files/node__definitions__4_8h/#define-sck","text":"#define SCK 5","title":"define SCK"},{"location":"Node/Files/node__definitions__4_8h/#define-miso","text":"#define MISO 19","title":"define MISO"},{"location":"Node/Files/node__definitions__4_8h/#define-mosi","text":"#define MOSI 27","title":"define MOSI"},{"location":"Node/Files/node__definitions__4_8h/#define-ss","text":"#define SS 18","title":"define SS"},{"location":"Node/Files/node__definitions__4_8h/#define-rst","text":"#define RST 14","title":"define RST"},{"location":"Node/Files/node__definitions__4_8h/#define-dio0","text":"#define DIO0 26","title":"define DIO0"},{"location":"Node/Files/node__definitions__4_8h/#source-code","text":"#ifndef NODE_DEFINITIONS_4_H #define NODE_DEFINITIONS_4_H // Node Encryption key const uint8_t key[] = { // 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x4f }; // SPI pinout for TTGO boards #define SCK 5 #define MISO 19 #define MOSI 27 // LoRa Modem Pinout for TTGO boards #define SS 18 #define RST 14 #define DIO0 26 // Node Settings const byte nodeID = 0x04; // Node I/O Pinout const int vbatPin = 35; const int sensPin[] = {16}; const int actPin[] = {LED_BUILTIN}; #endif Updated on 2022-08-25 at 10:49:36 +0000","title":"Source code"},{"location":"Node/Files/node__definitions__uno_8h/","text":"/sensor_network/node/node_definitions/node_definitions_uno.h Definitions for node with id 1. More... Attributes Name const uint8_t key const byte nodeID const int sensPin const int actPin Defines Name SS RST DIO0 Detailed Description Definitions for node with id 1. Author : Francisco Santos ( francisco.velez@tecnico.ulisboa.pt ) Version : 1.0 Date : 2022-08-10 Copyright : Copyright (c) 2022 Attributes Documentation variable key const uint8_t key = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f }; variable nodeID const byte nodeID = 0x01; variable sensPin const int sensPin = {}; variable actPin const int actPin = {4}; Macros Documentation define SS #define SS 10 define RST #define RST 9 define DIO0 #define DIO0 2 Source code #ifndef NODE_DEFINITIONS_1_H #define NODE_DEFINITIONS_1_H // Node Encryption key const uint8_t key[] = { // 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f }; // LoRa Modem Pinout for boards with the Dragino LoRa shield #define SS 10 #define RST 9 #define DIO0 2 // Node Settings const byte nodeID = 0x01; // Node I/O Pinout const int sensPin[] = {}; const int actPin[] = {4}; #endif Updated on 2022-08-25 at 10:49:36 +0000","title":"/sensor_network/node/node_definitions/node_definitions_uno.h"},{"location":"Node/Files/node__definitions__uno_8h/#sensor_networknodenode_definitionsnode_definitions_unoh","text":"Definitions for node with id 1. More...","title":"/sensor_network/node/node_definitions/node_definitions_uno.h"},{"location":"Node/Files/node__definitions__uno_8h/#attributes","text":"Name const uint8_t key const byte nodeID const int sensPin const int actPin","title":"Attributes"},{"location":"Node/Files/node__definitions__uno_8h/#defines","text":"Name SS RST DIO0","title":"Defines"},{"location":"Node/Files/node__definitions__uno_8h/#detailed-description","text":"Definitions for node with id 1. Author : Francisco Santos ( francisco.velez@tecnico.ulisboa.pt ) Version : 1.0 Date : 2022-08-10 Copyright : Copyright (c) 2022","title":"Detailed Description"},{"location":"Node/Files/node__definitions__uno_8h/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Node/Files/node__definitions__uno_8h/#variable-key","text":"const uint8_t key = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f };","title":"variable key"},{"location":"Node/Files/node__definitions__uno_8h/#variable-nodeid","text":"const byte nodeID = 0x01;","title":"variable nodeID"},{"location":"Node/Files/node__definitions__uno_8h/#variable-senspin","text":"const int sensPin = {};","title":"variable sensPin"},{"location":"Node/Files/node__definitions__uno_8h/#variable-actpin","text":"const int actPin = {4};","title":"variable actPin"},{"location":"Node/Files/node__definitions__uno_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"Node/Files/node__definitions__uno_8h/#define-ss","text":"#define SS 10","title":"define SS"},{"location":"Node/Files/node__definitions__uno_8h/#define-rst","text":"#define RST 9","title":"define RST"},{"location":"Node/Files/node__definitions__uno_8h/#define-dio0","text":"#define DIO0 2","title":"define DIO0"},{"location":"Node/Files/node__definitions__uno_8h/#source-code","text":"#ifndef NODE_DEFINITIONS_1_H #define NODE_DEFINITIONS_1_H // Node Encryption key const uint8_t key[] = { // 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f }; // LoRa Modem Pinout for boards with the Dragino LoRa shield #define SS 10 #define RST 9 #define DIO0 2 // Node Settings const byte nodeID = 0x01; // Node I/O Pinout const int sensPin[] = {}; const int actPin[] = {4}; #endif Updated on 2022-08-25 at 10:49:36 +0000","title":"Source code"},{"location":"Node/Modules/","text":"Modules Updated on 2022-08-25 at 10:49:36 +0000","title":"Modules"},{"location":"Node/Modules/#modules","text":"Updated on 2022-08-25 at 10:49:36 +0000","title":"Modules"},{"location":"Node/Namespaces/","text":"Namespaces Updated on 2022-08-25 at 10:49:36 +0000","title":"Namespaces"},{"location":"Node/Namespaces/#namespaces","text":"Updated on 2022-08-25 at 10:49:36 +0000","title":"Namespaces"},{"location":"Node/Pages/","text":"Pages Updated on 2022-08-25 at 10:49:36 +0000","title":"Pages"},{"location":"Node/Pages/#pages","text":"Updated on 2022-08-25 at 10:49:36 +0000","title":"Pages"},{"location":"pages/example_usage/","text":"Sensor Network Example Usage","title":"Example Usage"},{"location":"pages/example_usage/#sensor-network","text":"","title":"Sensor Network"},{"location":"pages/example_usage/#example-usage","text":"","title":"Example Usage"},{"location":"pages/install_guide/","text":"Sensor Network Install Guide","title":"Install Guide"},{"location":"pages/install_guide/#sensor-network","text":"","title":"Sensor Network"},{"location":"pages/install_guide/#install-guide","text":"","title":"Install Guide"},{"location":"pages/repo_structure/","text":"Sensor Network Repository Structure","title":"Repository Structure"},{"location":"pages/repo_structure/#sensor-network","text":"","title":"Sensor Network"},{"location":"pages/repo_structure/#repository-structure","text":"","title":"Repository Structure"}]}